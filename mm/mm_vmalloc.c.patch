--- original/mm/vmalloc.c	2020-05-07 08:51:35.486251605 +0200
+++ changed/mm/vmalloc.c	2019-06-03 13:39:54.000000000 +0200
@@ -34,6 +34,8 @@
 #include <asm/tlbflush.h>
 #include <asm/shmparam.h>
 
+atomic_long_t nr_vmalloc_pages;
+
 struct vfree_deferred {
 	struct llist_head list;
 	struct work_struct wq;
@@ -1547,6 +1549,7 @@ static void __vunmap(const void *addr, i
 			BUG_ON(!page);
 			__free_page(page);
 		}
+		atomic_long_sub(area->nr_pages, &nr_vmalloc_pages);
 
 		if (area->flags & VM_VPAGES)
 			vfree(area->pages);
@@ -1689,6 +1692,7 @@ static void *__vmalloc_area_node(struct
 		if (gfp_mask & __GFP_WAIT)
 			cond_resched();
 	}
+	atomic_long_add(area->nr_pages, &nr_vmalloc_pages);
 
 	if (map_vm_area(area, prot, pages))
 		goto fail;
@@ -2753,9 +2757,32 @@ static const struct file_operations proc
 	.release	= seq_release_private,
 };
 
+static int vmalloc_size_notifier(struct notifier_block *nb,
+					unsigned long action, void *data)
+{
+	struct seq_file *s;
+
+	s = (struct seq_file *)data;
+	if (s != NULL)
+		seq_printf(s, "VmallocAPIsize: %8lu kB\n",
+			   atomic_long_read(&nr_vmalloc_pages)
+				 << (PAGE_SHIFT - 10));
+	else
+		pr_cont("VmallocAPIsize:%lukB ",
+			atomic_long_read(&nr_vmalloc_pages)
+				<< (PAGE_SHIFT - 10));
+	return 0;
+}
+
+static struct notifier_block vmalloc_size_nb = {
+	.notifier_call = vmalloc_size_notifier,
+};
+
 static int __init proc_vmalloc_init(void)
 {
 	proc_create("vmallocinfo", S_IRUSR, NULL, &proc_vmalloc_operations);
+	atomic_long_set(&nr_vmalloc_pages, 0);
+	show_mem_extra_notifier_register(&vmalloc_size_nb);
 	return 0;
 }
 module_init(proc_vmalloc_init);
