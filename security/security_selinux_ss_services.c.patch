--- original/security/selinux/ss/services.c	2020-05-07 08:31:28.436763399 +0200
+++ changed/security/selinux/ss/services.c	2019-06-03 13:39:54.000000000 +0200
@@ -773,6 +773,13 @@ out:
 	kfree(n);
 	kfree(t);
 
+// [ SEC_SELINUX_PORTING_COMMON
+#ifdef CONFIG_ALWAYS_ENFORCE
+#if !defined(CONFIG_RKP_KDP)
+	selinux_enforcing = 1;
+#endif
+#endif
+// ] SEC_SELINUX_PORTING_COMMON
 	if (!selinux_enforcing)
 		return 0;
 	return -EPERM;
@@ -1534,6 +1541,14 @@ out:
 	kfree(s);
 	kfree(t);
 	kfree(n);
+
+// [ SEC_SELINUX_PORTING_COMMON
+#ifdef CONFIG_ALWAYS_ENFORCE
+#if !defined(CONFIG_RKP_KDP)
+	selinux_enforcing = 1;
+#endif
+#endif
+// ] SEC_SELINUX_PORTING_COMMON
 	if (!selinux_enforcing)
 		return 0;
 	return -EACCES;
@@ -1825,6 +1840,11 @@ static inline int convert_context_handle
 	char *s;
 	u32 len;
 
+// [ SEC_SELINUX_PORTING_COMMON
+#ifdef CONFIG_ALWAYS_ENFORCE
+	selinux_enforcing = 1;
+#endif
+// ] SEC_SELINUX_PORTING_COMMON
 	if (selinux_enforcing)
 		return -EINVAL;
 
@@ -2464,9 +2484,9 @@ out:
  * The caller must acquire the policy_rwlock before calling this function.
  */
 static inline int __security_genfs_sid(const char *fstype,
-				       char *path,
-				       u16 orig_sclass,
-				       u32 *sid)
+					   char *path,
+					   u16 orig_sclass,
+					   u32 *sid)
 {
 	int len;
 	u16 sclass;
@@ -2487,24 +2507,30 @@ static inline int __security_genfs_sid(c
 	}
 
 	rc = -ENOENT;
-	if (!genfs || cmp)
+	if (!genfs || cmp){
+		printk(KERN_ERR "SELinux: %s: genfs || cmp\n", __func__);
 		goto out;
+	}
 
 	for (c = genfs->head; c; c = c->next) {
 		len = strlen(c->u.name);
 		if ((!c->v.sclass || sclass == c->v.sclass) &&
-		    (strncmp(c->u.name, path, len) == 0))
+			(strncmp(c->u.name, path, len) == 0))
 			break;
 	}
 
 	rc = -ENOENT;
-	if (!c)
+	if (!c) {
+		printk(KERN_ERR "SELinux: %s empty ocontext c \n", __func__);
 		goto out;
+	}
 
 	if (!c->sid[0]) {
 		rc = sidtab_context_to_sid(&sidtab, &c->context[0], &c->sid[0]);
-		if (rc)
+		if (rc) {
+			printk(KERN_ERR "SELinux: %s: sid\n", __func__);
 			goto out;
+		}
 	}
 
 	*sid = c->sid[0];
@@ -2544,6 +2570,8 @@ int security_fs_use(struct super_block *
 {
 	int rc = 0;
 	struct ocontext *c;
+	u32 tmpsid;
+
 	struct superblock_security_struct *sbsec = sb->s_security;
 	const char *fstype = sb->s_type->name;
 
@@ -2560,21 +2588,22 @@ int security_fs_use(struct super_block *
 		sbsec->behavior = c->v.behavior;
 		if (!c->sid[0]) {
 			rc = sidtab_context_to_sid(&sidtab, &c->context[0],
-						   &c->sid[0]);
+						   &tmpsid);
+			c->sid[0] = tmpsid;
 			if (rc)
 				goto out;
 		}
 		sbsec->sid = c->sid[0];
 	} else {
-		rc = __security_genfs_sid(fstype, "/", SECCLASS_DIR,
-					  &sbsec->sid);
-		if (rc) {
-			sbsec->behavior = SECURITY_FS_USE_NONE;
-			rc = 0;
-		} else {
-			sbsec->behavior = SECURITY_FS_USE_GENFS;
+			rc = __security_genfs_sid(fstype, "/", SECCLASS_DIR,
+						  &sbsec->sid);
+			if (rc) {
+				sbsec->behavior = SECURITY_FS_USE_NONE;
+				rc = 0;
+			} else {
+				sbsec->behavior = SECURITY_FS_USE_GENFS;
+			}
 		}
-	}
 
 out:
 	read_unlock(&policy_rwlock);
