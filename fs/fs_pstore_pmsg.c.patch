--- original/fs/pstore/pmsg.c	2020-05-07 08:31:26.638779574 +0200
+++ changed/fs/pstore/pmsg.c	2019-06-03 13:39:53.000000000 +0200
@@ -19,25 +19,49 @@
 #include "internal.h"
 
 static DEFINE_MUTEX(pmsg_lock);
+static char *pmsg_buffer;
+#define PMSG_MAX_BOUNCE_BUFFER_SIZE (2*PAGE_SIZE)
 
 static ssize_t write_pmsg(struct file *file, const char __user *buf,
 			  size_t count, loff_t *ppos)
 {
-	u64 id;
-	int ret;
+	size_t i, buffer_size;
+	char *buffer = pmsg_buffer;
 
 	if (!count)
 		return 0;
 
-	/* check outside lock, page in any data. write_buf_user also checks */
 	if (!access_ok(VERIFY_READ, buf, count))
 		return -EFAULT;
 
+	buffer_size = count;
+	if (buffer_size > PMSG_MAX_BOUNCE_BUFFER_SIZE)
+		buffer_size = PMSG_MAX_BOUNCE_BUFFER_SIZE;
+
 	mutex_lock(&pmsg_lock);
-	ret = psinfo->write_buf_user(PSTORE_TYPE_PMSG, 0, &id, 0, buf, 0, count,
-				     psinfo);
+	for (i = 0; i < count; ) {
+		size_t c = min(count - i, buffer_size);
+		u64 id;
+		long ret;
+
+		ret = __copy_from_user(buffer, buf + i, c);
+		if (unlikely(ret != 0)) {
+			mutex_unlock(&pmsg_lock);
+			return -EFAULT;
+		}
+
+		psinfo->write_buf(PSTORE_TYPE_PMSG, 0, &id, 0, buffer, 0, c,
+				  psinfo);
+
+#ifdef CONFIG_SEC_DEBUG
+		ss_hook_pmsg(buffer, c);
+#endif
+
+		i += c;
+	}
+
 	mutex_unlock(&pmsg_lock);
-	return ret ? ret : count;
+	return count;
 }
 
 static const struct file_operations pmsg_fops = {
@@ -82,6 +106,13 @@ void pstore_register_pmsg(void)
 		pr_err("failed to create device\n");
 		goto err_device;
 	}
+
+	pmsg_buffer = vmalloc(PMSG_MAX_BOUNCE_BUFFER_SIZE);
+
+	if (!pmsg_buffer) {
+		pr_err("failed to create pmsg buffer\n");
+		goto err_device;
+	}
 	return;
 
 err_device:
