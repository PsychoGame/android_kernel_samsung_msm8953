--- original/fs/ecryptfs/keystore.c	2020-05-07 08:31:26.342782237 +0200
+++ changed/fs/ecryptfs/keystore.c	2019-06-03 13:39:53.000000000 +0200
@@ -32,8 +32,50 @@
 #include <linux/crypto.h>
 #include <linux/scatterlist.h>
 #include <linux/slab.h>
+#ifdef CONFIG_ECRYPTFS_FEK_INTEGRITY
+#include <crypto/hash.h>
+#endif
 #include "ecryptfs_kernel.h"
 
+#ifdef CONFIG_SDP
+#include "ecryptfs_dek.h"
+#endif
+
+#ifdef CONFIG_ECRYPTFS_FEK_INTEGRITY
+static int eCryptfs_hmac_sha256(u8 *key, u8 ksize, char *plaintext, u8 psize, u8 *output)
+{
+	struct crypto_shash *tfm;
+	int rc = 0;
+	if (!ksize || !psize)
+		return -EINVAL;
+	if (key == NULL || plaintext == NULL || output == NULL)
+		return -EINVAL;
+
+	tfm = crypto_alloc_shash("hmac(sha256)", 0, 0);
+	if (IS_ERR(tfm)) {
+		ecryptfs_printk(KERN_ERR, "crypto_alloc_ahash failed: err %ld", PTR_ERR(tfm));
+		return PTR_ERR(tfm);
+	}
+	rc = crypto_shash_setkey(tfm, key, ksize);
+	if (rc) {
+		ecryptfs_printk(KERN_ERR, "crypto_ahash_setkey failed: err %d", rc);
+	} else {
+		char desc[sizeof(struct shash_desc) +
+			crypto_shash_descsize(tfm)] CRYPTO_MINALIGN_ATTR;
+		struct shash_desc *shash = (struct shash_desc *)desc;
+
+		shash->tfm = tfm;
+		shash->flags = CRYPTO_TFM_REQ_MAY_SLEEP;
+
+		rc = crypto_shash_digest(shash, plaintext, psize,
+					  output);
+	}
+
+	crypto_free_shash(tfm);	
+	return rc;
+}
+#endif
+
 /**
  * request_key returned an error instead of a valid key address;
  * determine the type of error, make appropriate log entries, and
@@ -664,9 +706,15 @@ ecryptfs_write_tag_70_packet(char *dest,
 		       mount_crypt_stat->global_default_fnek_sig, rc);
 		goto out;
 	}
+#ifdef CONFIG_CRYPTO_FIPS
+	rc = ecryptfs_get_tfm_and_mutex_for_cipher_name(
+		&s->desc.tfm,
+		&s->tfm_mutex, mount_crypt_stat->global_default_fn_cipher_name, mount_crypt_stat->flags);
+#else
 	rc = ecryptfs_get_tfm_and_mutex_for_cipher_name(
 		&s->desc.tfm,
 		&s->tfm_mutex, mount_crypt_stat->global_default_fn_cipher_name);
+#endif
 	if (unlikely(rc)) {
 		printk(KERN_ERR "Internal error whilst attempting to get "
 		       "tfm and mutex for cipher name [%s]; rc = [%d]\n",
@@ -1012,9 +1060,15 @@ ecryptfs_parse_tag_70_packet(char **file
 		       rc);
 		goto out;
 	}
+#ifdef CONFIG_CRYPTO_FIPS
+	rc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&s->desc.tfm,
+							&s->tfm_mutex,
+							s->cipher_string, mount_crypt_stat->flags);
+#else
 	rc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&s->desc.tfm,
 							&s->tfm_mutex,
 							s->cipher_string);
+#endif
 	if (unlikely(rc)) {
 		printk(KERN_ERR "Internal error whilst attempting to get "
 		       "tfm and mutex for cipher name [%s]; rc = [%d]\n",
@@ -1710,6 +1764,13 @@ decrypt_passphrase_encrypted_session_key
 	};
 	int rc = 0;
 	u32 decrypted_key_size = 0;
+#ifdef CONFIG_CRYPTO_FIPS
+	char iv[ECRYPTFS_DEFAULT_IV_BYTES];
+#endif
+#ifdef CONFIG_ECRYPTFS_FEK_INTEGRITY
+	unsigned char hmac_hash[FEK_HASH_SIZE];
+	int rz = 0;
+#endif
 
 	if (unlikely(ecryptfs_verbosity > 0)) {
 		ecryptfs_printk(
@@ -1719,8 +1780,13 @@ decrypt_passphrase_encrypted_session_key
 			auth_tok->token.password.session_key_encryption_key,
 			auth_tok->token.password.session_key_encryption_key_bytes);
 	}
+#ifdef CONFIG_CRYPTO_FIPS
+	rc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&desc.tfm, &tfm_mutex,
+							crypt_stat->cipher, crypt_stat->mount_crypt_stat->flags);
+#else
 	rc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&desc.tfm, &tfm_mutex,
 							crypt_stat->cipher);
+#endif
 	if (unlikely(rc)) {
 		printk(KERN_ERR "Internal error whilst attempting to get "
 		       "tfm and mutex for cipher name [%s]; rc = [%d]\n",
@@ -1752,20 +1818,74 @@ decrypt_passphrase_encrypted_session_key
 	mutex_lock(tfm_mutex);
 	rc = crypto_blkcipher_setkey(
 		desc.tfm, auth_tok->token.password.session_key_encryption_key,
-		auth_tok->token.password.session_key_encryption_key_bytes);
+		crypt_stat->key_size);
 	if (unlikely(rc < 0)) {
 		mutex_unlock(tfm_mutex);
 		printk(KERN_ERR "Error setting key for crypto context\n");
 		rc = -EINVAL;
 		goto out;
 	}
+#ifdef CONFIG_CRYPTO_FIPS
+	if (crypt_stat->mount_crypt_stat->flags & ECRYPTFS_ENABLE_CC)
+		crypto_blkcipher_get_iv(desc.tfm, iv, ECRYPTFS_DEFAULT_IV_BYTES);
+#endif
 	rc = crypto_blkcipher_decrypt(&desc, dst_sg, src_sg,
 				      auth_tok->session_key.encrypted_key_size);
+#ifdef CONFIG_ECRYPTFS_FEK_INTEGRITY
+#ifdef CONFIG_SDP
+	if(!(crypt_stat->flags & ECRYPTFS_DEK_IS_SENSITIVE)) {
+#endif
+	if(crypt_stat->flags & ECRYPTFS_ENABLE_HMAC) {
+		if (crypt_stat->flags & ECRYPTFS_SUPPORT_HMAC_KEY
+				&& auth_tok->token.password.session_key_encryption_key_bytes == ECRYPTFS_MAX_KEY_BYTES) {
+			rz = eCryptfs_hmac_sha256(auth_tok->token.password.session_key_encryption_key + SEC_ECRYPTFS_HMAC_KEY_SIZE,
+				crypt_stat->key_size, auth_tok->session_key.decrypted_key, auth_tok->session_key.encrypted_key_size, hmac_hash);
+		} else {
+			rz = eCryptfs_hmac_sha256(auth_tok->token.password.session_key_encryption_key,
+				crypt_stat->key_size, auth_tok->session_key.decrypted_key, auth_tok->session_key.encrypted_key_size, hmac_hash);
+		}
+
+		if (unlikely(rz)) {
+			mutex_unlock(tfm_mutex);
+			ecryptfs_printk(KERN_ERR, "Error Generating Hash : rz = [%d]\n", rz);
+			return rz;
+		}
+		if(memcmp(crypt_stat->hash, hmac_hash, FEK_HASH_SIZE)) {
+			ecryptfs_printk(KERN_ERR, "FEK Integrity Verification Failed...\n");
+			mutex_unlock(tfm_mutex);
+			return -1;
+		}
+	}
+	else {
+		ecryptfs_printk(KERN_INFO, "HMAC HASH is Not Present in SD Card...\n");
+	}
+#ifdef CONFIG_SDP
+	}
+#endif
+#endif
+#ifdef CONFIG_CRYPTO_FIPS
+	if (crypt_stat->mount_crypt_stat->flags & ECRYPTFS_ENABLE_CC)
+		crypto_blkcipher_set_iv(desc.tfm, iv, ECRYPTFS_DEFAULT_IV_BYTES);
+	if (unlikely(rc)) {
+		mutex_unlock(tfm_mutex);
+		printk(KERN_ERR "Error decrypting; rc = [%d]\n", rc);
+		goto out;
+	}
+	/* Session key(the key to decrypt file encryption keys) CLEAR! */
+	memset(auth_tok->token.password.session_key_encryption_key, 0, ECRYPTFS_MAX_KEY_BYTES);
+	rc = crypto_blkcipher_setkey(desc.tfm, auth_tok->token.password.session_key_encryption_key, crypt_stat->key_size);
+	mutex_unlock(tfm_mutex);
+	if (unlikely(rc < 0)) {
+		printk(KERN_ERR "Error(decrypt) Session Key CLEAR in desc.tfm; rc = [%d]\n", rc);
+	}
+	rc = 0;
+#else
 	mutex_unlock(tfm_mutex);
 	if (unlikely(rc)) {
 		printk(KERN_ERR "Error decrypting; rc = [%d]\n", rc);
 		goto out;
 	}
+#endif
 	auth_tok->session_key.flags |= ECRYPTFS_CONTAINS_DECRYPTED_KEY;
 
 	decrypted_key_size = (auth_tok->session_key.decrypted_key_size <=
@@ -1775,6 +1895,14 @@ decrypt_passphrase_encrypted_session_key
 	memcpy(crypt_stat->key, auth_tok->session_key.decrypted_key,
 			decrypted_key_size);
 	crypt_stat->flags |= ECRYPTFS_KEY_VALID;
+
+#ifdef CONFIG_CRYPTO_FIPS
+	/* File encryption key CLEAR! */
+	memset(auth_tok->session_key.decrypted_key, 0, decrypted_key_size);
+	auth_tok->session_key.decrypted_key_size = 0;
+	auth_tok->session_key.flags &= ~ECRYPTFS_CONTAINS_DECRYPTED_KEY;
+#endif
+
 	if (unlikely(ecryptfs_verbosity > 0)) {
 		ecryptfs_printk(KERN_DEBUG, "FEK of size [%zd]:\n",
 				crypt_stat->key_size);
@@ -1819,13 +1947,27 @@ int ecryptfs_parse_packet_set(struct ecr
 	size_t tag_11_packet_size;
 	struct key *auth_tok_key = NULL;
 	int rc = 0;
+#ifdef CONFIG_ECRYPTFS_FEK_INTEGRITY
+#ifdef CONFIG_SDP
+	char session_key_encryption_key[ECRYPTFS_MAX_KEY_BYTES];
+	int is_integrity_check_for_sdp = 0;
+	u8 ksize = 0;
+	int rz = 0;
+#endif
+#endif
 
 	INIT_LIST_HEAD(&auth_tok_list);
 	/* Parse the header to find as many packets as we can; these will be
 	 * added the our &auth_tok_list */
 	next_packet_is_auth_tok_packet = 1;
 	while (next_packet_is_auth_tok_packet) {
-		size_t max_packet_size = ((PAGE_CACHE_SIZE - 8) - i);
+		size_t max_packet_size;
+		if ((PAGE_CACHE_SIZE - 8) < i) {
+			printk(KERN_WARNING "%s: Invalid max packet size\n", __func__);
+			rc = -EINVAL;
+			goto out;
+		}
+		max_packet_size = ((PAGE_CACHE_SIZE - 8) - i);
 
 		switch (src[i]) {
 		case ECRYPTFS_TAG_3_PACKET_TYPE:
@@ -1891,6 +2033,23 @@ int ecryptfs_parse_packet_set(struct ecr
 					"(Tag 11 not allowed by itself)\n");
 			rc = -EIO;
 			goto out_wipe_list;
+			break;
+#ifdef CONFIG_SDP
+		case ECRYPTFS_DEK_PACKET_TYPE:
+			printk("%s() ECRYPTFS_DEK_PACKET_TYPE \n",
+					__func__);
+			rc = parse_dek_packet(
+					(unsigned char *)&src[i], crypt_stat,
+					&packet_size);
+			if (rc) {
+				ecryptfs_printk(KERN_ERR, "Error parsing "
+						"dek packet %d\n", rc);
+			rc = -EIO;
+			goto out_wipe_list;
+			}
+			i += packet_size;
+			break;
+#endif
 		default:
 			ecryptfs_printk(KERN_DEBUG, "No packet at offset [%zd] "
 					"of the file header; hex value of "
@@ -1959,6 +2118,17 @@ found_matching_auth_tok:
 		       sizeof(struct ecryptfs_password));
 		up_write(&(auth_tok_key->sem));
 		key_put(auth_tok_key);
+#ifdef CONFIG_ECRYPTFS_FEK_INTEGRITY
+#ifdef CONFIG_SDP
+		if((crypt_stat->flags & ECRYPTFS_DEK_IS_SENSITIVE)) {
+			memcpy(session_key_encryption_key,
+					candidate_auth_tok->token.password.session_key_encryption_key,
+					candidate_auth_tok->token.password.session_key_encryption_key_bytes);
+			is_integrity_check_for_sdp = 1;
+			ksize = candidate_auth_tok->token.password.session_key_encryption_key_bytes;
+		}
+#endif
+#endif
 		rc = decrypt_passphrase_encrypted_session_key(
 			candidate_auth_tok, crypt_stat);
 	} else {
@@ -1968,7 +2138,13 @@ found_matching_auth_tok:
 	}
 	if (rc) {
 		struct ecryptfs_auth_tok_list_item *auth_tok_list_item_tmp;
-
+#ifdef CONFIG_ECRYPTFS_FEK_INTEGRITY
+#ifdef CONFIG_SDP
+		if (is_integrity_check_for_sdp) {
+			memset(session_key_encryption_key, 0, ksize);
+		}
+#endif
+#endif
 		ecryptfs_printk(KERN_WARNING, "Error decrypting the "
 				"session key for authentication token with sig "
 				"[%.*s]; rc = [%d]. Removing auth tok "
@@ -1989,6 +2165,39 @@ found_matching_auth_tok:
 		}
 		BUG();
 	}
+
+#ifdef CONFIG_SDP
+	if((crypt_stat->flags & ECRYPTFS_DEK_IS_SENSITIVE)) {
+		rc = ecryptfs_get_sdp_dek(crypt_stat);
+		if (rc) {
+			ecryptfs_printk(KERN_ERR, "Error setting sdp key after parse\n");
+			goto out_wipe_list;
+		}
+#ifdef CONFIG_ECRYPTFS_FEK_INTEGRITY
+		if(is_integrity_check_for_sdp 
+				&& crypt_stat->flags & ECRYPTFS_ENABLE_HMAC) {//Do integrity check for SDP-FEK
+			unsigned char hmac_hash[FEK_HASH_SIZE];
+			rz = eCryptfs_hmac_sha256(session_key_encryption_key,
+					crypt_stat->key_size,
+					crypt_stat->key,
+					crypt_stat->key_size,
+					hmac_hash);
+			
+			memset(session_key_encryption_key, 0, ksize);
+			
+			if (unlikely(rz)) {
+				ecryptfs_printk(KERN_ERR, "Error Generating Hash for SDP FEK: rz = [%d]\n", rz);
+				goto out_wipe_list;
+			}
+			
+			if (memcmp(crypt_stat->hash, hmac_hash, FEK_HASH_SIZE)) {
+				ecryptfs_printk(KERN_ERR, "SDP FEK Integrity Verification Failed...\n");
+				goto out_wipe_list;
+			}
+		}
+#endif
+	}
+#endif
 	rc = ecryptfs_compute_root_iv(crypt_stat);
 	if (rc) {
 		ecryptfs_printk(KERN_ERR, "Error computing "
@@ -2234,6 +2443,7 @@ write_tag_3_packet(char *dest, size_t *r
 	size_t i;
 	size_t encrypted_session_key_valid = 0;
 	char session_key_encryption_key[ECRYPTFS_MAX_KEY_BYTES];
+	char session_hmac_key[SEC_ECRYPTFS_HMAC_KEY_SIZE];
 	struct scatterlist dst_sg[2];
 	struct scatterlist src_sg[2];
 	struct mutex *tfm_mutex = NULL;
@@ -2249,12 +2459,20 @@ write_tag_3_packet(char *dest, size_t *r
 	};
 	int rc = 0;
 	size_t enc_key_size = 0;
+#ifdef CONFIG_CRYPTO_FIPS
+	char iv[ECRYPTFS_DEFAULT_IV_BYTES];
+#endif
 
 	(*packet_size) = 0;
 	ecryptfs_from_hex(key_rec->sig, auth_tok->token.password.signature,
 			  ECRYPTFS_SIG_SIZE);
+#ifdef CONFIG_CRYPTO_FIPS
+	rc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&desc.tfm, &tfm_mutex,
+							crypt_stat->cipher, crypt_stat->mount_crypt_stat->flags);
+#else
 	rc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&desc.tfm, &tfm_mutex,
 							crypt_stat->cipher);
+#endif
 	if (unlikely(rc)) {
 		printk(KERN_ERR "Internal error whilst attempting to get "
 		       "tfm and mutex for cipher name [%s]; rc = [%d]\n",
@@ -2305,8 +2523,16 @@ write_tag_3_packet(char *dest, size_t *r
 				auth_tok->token.password.
 				session_key_encryption_key_bytes);
 		memcpy(session_key_encryption_key,
-		auth_tok->token.password.session_key_encryption_key,
-		auth_tok->token.password.session_key_encryption_key_bytes);
+		       auth_tok->token.password.session_key_encryption_key,
+		       crypt_stat->key_size);
+			   			   
+		if (crypt_stat->flags & ECRYPTFS_SUPPORT_HMAC_KEY 
+				&& auth_tok->token.password.session_key_encryption_key_bytes == ECRYPTFS_MAX_KEY_BYTES){
+			memcpy(session_hmac_key,
+				auth_tok->token.password.session_key_encryption_key + SEC_ECRYPTFS_HMAC_KEY_SIZE,
+				crypt_stat->key_size);
+		}
+			   
 		ecryptfs_printk(KERN_DEBUG,
 				"Cached session key encryption key:\n");
 		if (ecryptfs_verbosity > 0)
@@ -2316,6 +2542,24 @@ write_tag_3_packet(char *dest, size_t *r
 		ecryptfs_printk(KERN_DEBUG, "Session key encryption key:\n");
 		ecryptfs_dump_hex(session_key_encryption_key, 16);
 	}
+#ifdef CONFIG_ECRYPTFS_FEK_INTEGRITY
+	if(crypt_stat->flags & ECRYPTFS_ENABLE_HMAC) {
+		if(crypt_stat->flags & ECRYPTFS_SUPPORT_HMAC_KEY 
+				&& auth_tok->token.password.session_key_encryption_key_bytes == ECRYPTFS_MAX_KEY_BYTES ) {
+			rc = eCryptfs_hmac_sha256(session_hmac_key, crypt_stat->key_size,
+				crypt_stat->key, crypt_stat->key_size, crypt_stat->hash);
+		}else {
+			rc = eCryptfs_hmac_sha256(session_key_encryption_key, crypt_stat->key_size,
+				crypt_stat->key, crypt_stat->key_size, crypt_stat->hash);
+		}
+		
+		if (rc < 0) {
+			mutex_unlock(tfm_mutex);
+			ecryptfs_printk(KERN_ERR, "Error Generating Hash for FEK : rc = [%d]\n", rc);
+			goto out;
+		}
+	}
+#endif
 	rc = virt_to_scatterlist(crypt_stat->key, key_rec->enc_key_size,
 				 src_sg, 2);
 	if (rc < 1 || rc > 2) {
@@ -2339,7 +2583,7 @@ write_tag_3_packet(char *dest, size_t *r
 	}
 	mutex_lock(tfm_mutex);
 	rc = crypto_blkcipher_setkey(desc.tfm, session_key_encryption_key,
-		auth_tok->token.password.session_key_encryption_key_bytes);
+		crypt_stat->key_size);
 	if (rc < 0) {
 		mutex_unlock(tfm_mutex);
 		ecryptfs_printk(KERN_ERR, "Error setting key for crypto "
@@ -2351,13 +2595,35 @@ write_tag_3_packet(char *dest, size_t *r
 		crypt_stat->key_size);
 	ecryptfs_printk(KERN_DEBUG, "Encrypting [%zd] bytes of the salt key\n",
 		ecryptfs_get_salt_size_for_cipher(crypt_stat));
+#ifdef CONFIG_CRYPTO_FIPS
+	if (crypt_stat->mount_crypt_stat->flags & ECRYPTFS_ENABLE_CC)
+		crypto_blkcipher_get_iv(desc.tfm, iv, ECRYPTFS_DEFAULT_IV_BYTES);
+#endif
 	rc = crypto_blkcipher_encrypt(&desc, dst_sg, src_sg,
 				      (*key_rec).enc_key_size);
+#ifdef CONFIG_CRYPTO_FIPS
+	if (crypt_stat->mount_crypt_stat->flags & ECRYPTFS_ENABLE_CC)
+		crypto_blkcipher_set_iv(desc.tfm, iv, ECRYPTFS_DEFAULT_IV_BYTES);
+	if (rc) {
+		mutex_unlock(tfm_mutex);
+		printk(KERN_ERR "Error encrypting; rc = [%d]\n", rc);
+		goto out;
+	}
+	/* Session key(the key to encrypt file encryption keys) CLEAR! */
+	memset( session_key_encryption_key, 0, ECRYPTFS_MAX_KEY_BYTES );
+	rc = crypto_blkcipher_setkey(desc.tfm, session_key_encryption_key, crypt_stat->key_size);
+	mutex_unlock(tfm_mutex);
+	if (rc) {
+		printk(KERN_ERR "Error(encrypt) Session Key CLEAR in desc.tfm; rc = [%d]\n", rc);
+	}
+	rc = 0;
+#else
 	mutex_unlock(tfm_mutex);
 	if (rc) {
 		printk(KERN_ERR "Error encrypting; rc = [%d]\n", rc);
 		goto out;
 	}
+#endif
 	ecryptfs_printk(KERN_DEBUG, "This should be the encrypted key:\n");
 	if (ecryptfs_verbosity > 0) {
 		ecryptfs_printk(KERN_DEBUG, "EFEK of size [%zd]:\n",
@@ -2421,9 +2687,20 @@ encrypted_session_key_set:
 	       ECRYPTFS_SALT_SIZE);
 	(*packet_size) += ECRYPTFS_SALT_SIZE;	/* salt */
 	dest[(*packet_size)++] = 0x60;	/* hash iterations (65536) */
+#ifdef CONFIG_SDP
+	if ((crypt_stat->flags & ECRYPTFS_DEK_IS_SENSITIVE)) {
+		ecryptfs_printk(KERN_DEBUG, "Sensitive file, tag_3 to zeroes\n");
+		memset(&dest[(*packet_size)], 0, key_rec->enc_key_size);
+	} else {
+		memcpy(&dest[(*packet_size)], key_rec->enc_key,
+		       key_rec->enc_key_size);
+	}
+	(*packet_size) += key_rec->enc_key_size;
+#else
 	memcpy(&dest[(*packet_size)], key_rec->enc_key,
 	       key_rec->enc_key_size);
 	(*packet_size) += key_rec->enc_key_size;
+#endif
 out:
 	if (rc)
 		(*packet_size) = 0;
@@ -2508,6 +2785,19 @@ ecryptfs_generate_key_packet_set(char *d
 				goto out_free;
 			}
 			(*len) += written;
+#ifdef CONFIG_SDP
+			if (crypt_stat->flags & ECRYPTFS_DEK_SDP_ENABLED &&
+				crypt_stat->flags & ECRYPTFS_DEK_IS_SENSITIVE) {
+				rc = write_dek_packet(dest_base + (*len), crypt_stat,
+						&written);
+				if (rc) {
+					ecryptfs_printk(KERN_WARNING, "Error "
+							"writing dek packet\n");
+					goto out_free;
+				}
+				(*len) += written;
+			}
+#endif
 		} else if (auth_tok->token_type == ECRYPTFS_PRIVATE_KEY) {
 			rc = write_tag_1_packet(dest_base + (*len), &max,
 						auth_tok_key, auth_tok,
