--- original/fs/file.c	2020-05-07 08:06:20.144204285 +0200
+++ changed/fs/file.c	2019-06-03 13:39:53.000000000 +0200
@@ -23,6 +23,8 @@
 #include <linux/rcupdate.h>
 #include <linux/workqueue.h>
 
+#include <linux/sec_debug.h>
+
 int sysctl_nr_open __read_mostly = 1024*1024;
 int sysctl_nr_open_min = BITS_PER_LONG;
 /* our max() is unusable in constant expressions ;-/ */
@@ -155,6 +157,7 @@ static int expand_fdtable(struct files_s
 	 * caller and alloc_fdtable().  Cheaper to catch it here...
 	 */
 	if (unlikely(new_fdt->max_fds <= nr)) {
+		sec_debug_EMFILE_error_proc();
 		__free_fdtable(new_fdt);
 		return -EMFILE;
 	}
@@ -195,8 +198,10 @@ static int expand_files(struct files_str
 		return 0;
 
 	/* Can we expand? */
-	if (nr >= sysctl_nr_open)
+	if (nr >= sysctl_nr_open) {
+		sec_debug_EMFILE_error_proc();
 		return -EMFILE;
+	}
 
 	/* All good, so we try */
 	return expand_fdtable(files, nr);
@@ -284,6 +289,7 @@ struct files_struct *dup_fd(struct files
 
 		/* beyond sysctl_nr_open; nothing to do */
 		if (unlikely(new_fdt->max_fds < open_files)) {
+			sec_debug_EMFILE_error_proc();
 			__free_fdtable(new_fdt);
 			*errorp = -EMFILE;
 			goto out_release;
@@ -464,8 +470,10 @@ repeat:
 	 * will limit the total number of files that can be opened.
 	 */
 	error = -EMFILE;
-	if (fd >= end)
+	if (fd >= end) {
+		sec_debug_EMFILE_error_proc();
 		goto out;
+	}
 
 	error = expand_files(files, fd);
 	if (error < 0)
@@ -826,8 +834,10 @@ SYSCALL_DEFINE3(dup3, unsigned int, oldf
 	if (unlikely(oldfd == newfd))
 		return -EINVAL;
 
-	if (newfd >= rlimit(RLIMIT_NOFILE))
+	if (newfd >= rlimit(RLIMIT_NOFILE)) {
+		sec_debug_EMFILE_error_proc();
 		return -EBADF;
+	}
 
 	spin_lock(&files->file_lock);
 	err = expand_files(files, newfd);
