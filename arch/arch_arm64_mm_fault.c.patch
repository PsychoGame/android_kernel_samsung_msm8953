--- original/arch/arm64/mm/fault.c	2020-05-07 08:31:20.419835522 +0200
+++ changed/arch/arm64/mm/fault.c	2019-06-03 13:39:48.000000000 +0200
@@ -41,6 +41,11 @@
 #include <asm/edac.h>
 
 #include <trace/events/exception.h>
+#include <linux/sec_debug.h>
+
+#ifdef CONFIG_USER_RESET_DEBUG
+#include <linux/user_reset/sec_debug_user_reset.h>
+#endif
 
 static const char *fault_name(unsigned int esr);
 
@@ -55,9 +60,18 @@ void show_pte(struct mm_struct *mm, unsi
 		mm = &init_mm;
 
 	pr_alert("pgd = %p\n", mm->pgd);
+#ifdef CONFIG_USER_RESET_DEBUG
+	sec_debug_store_pte((unsigned long)mm->pgd, 0);
+#endif
+
 	pgd = pgd_offset(mm, addr);
 	pr_alert("[%08lx] *pgd=%016llx", addr, pgd_val(*pgd));
 
+#ifdef CONFIG_USER_RESET_DEBUG
+	sec_debug_store_pte((unsigned long)addr, 1);
+	sec_debug_store_pte((unsigned long)pgd_val(*pgd), 2);
+#endif
+
 	do {
 		pud_t *pud;
 		pmd_t *pmd;
@@ -68,18 +82,27 @@ void show_pte(struct mm_struct *mm, unsi
 
 		pud = pud_offset(pgd, addr);
 		printk(", *pud=%016llx", pud_val(*pud));
+#ifdef CONFIG_USER_RESET_DEBUG
+		sec_debug_store_pte((unsigned long)pud_val(*pud), 3);
+#endif
 		if (pud_none(*pud) || pud_bad(*pud))
 			break;
 
 		pmd = pmd_offset(pud, addr);
 		printk(", *pmd=%016llx", pmd_val(*pmd));
+#ifdef CONFIG_USER_RESET_DEBUG
+		sec_debug_store_pte((unsigned long)pmd_val(*pmd), 4);
+#endif
 		if (pmd_none(*pmd) || pmd_bad(*pmd))
 			break;
 
 		pte = pte_offset_map(pmd, addr);
 		printk(", *pte=%016llx", pte_val(*pte));
+#ifdef CONFIG_USER_RESET_DEBUG
+		sec_debug_store_pte((unsigned long)pte_val(*pte), 5);
+#endif
 		pte_unmap(pte);
-	} while(0);
+	} while (0);
 
 	printk("\n");
 }
@@ -137,6 +160,11 @@ static void __do_user_fault(struct task_
 		show_regs(regs);
 	}
 
+	if (current->pid == 0x1) {
+		pr_err("[%s] trap before tragedy\n", current->comm);
+		panic("init");
+	}
+
 	tsk->thread.fault_address = addr;
 	tsk->thread.fault_code = esr;
 	si.si_signo = sig;
@@ -256,13 +284,12 @@ static int __kprobes do_page_fault(unsig
 		mm_flags |= FAULT_FLAG_WRITE;
 	}
 
-	if (addr < USER_DS && is_permission_fault(esr, regs)) {
-		if (is_el1_instruction_abort(esr))
-			die("Attempting to execute userspace memory", regs, esr);
-
-		if (!search_exception_tables(regs->pc))
-			panic("Accessing user space memory outside uaccess.h routines");
-	}
+	/*
+	 * PAN bit set implies the fault happened in kernel space, but not
+	 * in the arch's user access functions.
+	 */
+	if (IS_ENABLED(CONFIG_ARM64_PAN) && (regs->pstate & PSR_PAN_BIT))
+		goto no_context;
 
 	/*
 	 * As per x86, we may deadlock here. However, since the kernel only
@@ -406,6 +433,13 @@ static int __kprobes do_translation_faul
 	return 0;
 }
 
+static int do_alignment_fault(unsigned long addr, unsigned int esr,
+			      struct pt_regs *regs)
+{
+	do_bad_area(addr, esr, regs);
+	return 0;
+}
+
 /*
  * This abort handler always returns "fault".
  */
@@ -454,7 +488,7 @@ static const struct fault_info {
 	{ do_bad,		SIGBUS,  0,		"synchronous parity error (translation table walk" },
 	{ do_bad,		SIGBUS,  0,		"synchronous parity error (translation table walk" },
 	{ do_bad,		SIGBUS,  0,		"unknown 32"			},
-	{ do_bad,		SIGBUS,  BUS_ADRALN,	"alignment fault"		},
+	{ do_alignment_fault,	SIGBUS,  BUS_ADRALN,	"alignment fault"		},
 	{ do_bad,		SIGBUS,  0,		"debug event"			},
 	{ do_bad,		SIGBUS,  0,		"unknown 35"			},
 	{ do_bad,		SIGBUS,  0,		"unknown 36"			},
@@ -502,6 +536,10 @@ asmlinkage void __exception do_mem_abort
 	const struct fault_info *inf = fault_info + (esr & 63);
 	struct siginfo info;
 
+#ifdef CONFIG_USER_RESET_DEBUG
+	sec_debug_save_fault_info(esr, inf->name, addr, 0UL);
+#endif
+
 	if (!inf->fn(addr, esr, regs))
 		return;
 
@@ -540,6 +578,11 @@ asmlinkage void __exception do_sp_pc_abo
 {
 	struct siginfo info;
 
+#ifdef CONFIG_USER_RESET_DEBUG
+	sec_debug_save_fault_info(esr, esr_get_class_string(esr),
+			(unsigned long)regs->pc, (unsigned long)regs->sp);
+#endif
+
 	info.si_signo = SIGBUS;
 	info.si_errno = 0;
 	info.si_code  = BUS_ADRALN;
@@ -577,6 +620,10 @@ asmlinkage int __exception do_debug_exce
 	const struct fault_info *inf = debug_fault_info + DBG_ESR_EVT(esr);
 	struct siginfo info;
 
+#ifdef CONFIG_USER_RESET_DEBUG
+	sec_debug_save_fault_info(esr, inf->name, addr, 0UL);
+#endif
+
 	if (!inf->fn(addr, esr, regs))
 		return 1;
 
