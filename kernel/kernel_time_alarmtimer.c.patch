--- original/kernel/time/alarmtimer.c	2020-05-07 08:47:58.847373589 +0200
+++ changed/kernel/time/alarmtimer.c	2019-06-03 13:39:54.000000000 +0200
@@ -116,6 +116,111 @@ rtc_irq_reg_err:
 
 }
 
+#ifdef CONFIG_RTC_AUTO_PWRON
+/* 0|1234|56|78|90|12 */
+/* 1|2010|01|01|00|00 */
+/*en yyyy mm dd hh mm */
+#define BOOTALM_BIT_EN       0
+#define BOOTALM_BIT_YEAR     1
+#define BOOTALM_BIT_MONTH    5
+#define BOOTALM_BIT_DAY      7
+#define BOOTALM_BIT_HOUR     9
+#define BOOTALM_BIT_MIN     11
+#define BOOTALM_BIT_TOTAL   13
+
+int alarm_set_alarm(char *alarm_data)
+{
+	struct rtc_wkalrm alm;
+	int ret = 0;
+	char buf_ptr[BOOTALM_BIT_TOTAL+1];
+	struct rtc_time     rtc_tm;
+	unsigned long       rtc_sec;
+	unsigned long       rtc_alm_sec;
+	struct timespec     delta;
+	struct timespec     ktm_ts;
+	struct rtc_time     ktm_tm;
+
+	if (!rtcdev) {
+		printk(
+			"alarm_set_alarm: no RTC, time will be lost on reboot\n");
+		return -ENXIO;
+	}
+
+	strlcpy(buf_ptr, alarm_data, BOOTALM_BIT_TOTAL+1);
+
+	alm.time.tm_sec = 0;
+	alm.time.tm_min = (buf_ptr[BOOTALM_BIT_MIN]-'0') * 10
+					+ (buf_ptr[BOOTALM_BIT_MIN+1]-'0');
+	alm.time.tm_hour = (buf_ptr[BOOTALM_BIT_HOUR]-'0') * 10
+					+ (buf_ptr[BOOTALM_BIT_HOUR+1]-'0');
+	alm.time.tm_mday = (buf_ptr[BOOTALM_BIT_DAY]-'0') * 10
+					+ (buf_ptr[BOOTALM_BIT_DAY+1]-'0');
+	alm.time.tm_mon  = (buf_ptr[BOOTALM_BIT_MONTH]-'0') * 10
+	                  + (buf_ptr[BOOTALM_BIT_MONTH+1]-'0');
+	alm.time.tm_year = (buf_ptr[BOOTALM_BIT_YEAR]-'0') * 1000
+					+ (buf_ptr[BOOTALM_BIT_YEAR+1]-'0') * 100
+					+ (buf_ptr[BOOTALM_BIT_YEAR+2]-'0') * 10
+					+ (buf_ptr[BOOTALM_BIT_YEAR+3]-'0');
+
+	alm.enabled = (*buf_ptr == '1');
+	if (*buf_ptr == '2')
+		alm.enabled = 2;
+
+	pr_info("sapa %s: %s => tm(%d %04d-%02d-%02d %02d:%02d:%02d)\n",
+			__func__, buf_ptr, alm.enabled,
+			alm.time.tm_year, alm.time.tm_mon, alm.time.tm_mday,
+			alm.time.tm_hour, alm.time.tm_min, alm.time.tm_sec);
+
+	if (alm.enabled) {
+		/* read kernel time */
+		getnstimeofday(&ktm_ts);
+		ktm_tm = rtc_ktime_to_tm(timespec_to_ktime(ktm_ts));
+		pr_info("set_sapa: <KTM > %4d-%02d-%02d %02d:%02d:%02d\n",
+			ktm_tm.tm_year+1900, ktm_tm.tm_mon+1, ktm_tm.tm_mday,
+			ktm_tm.tm_hour, ktm_tm.tm_min, ktm_tm.tm_sec);
+
+		alm.time.tm_mon -= 1;
+		alm.time.tm_year -= 1900;
+		pr_info("set_sapa: <ALRM> %4d-%02d-%02d %02d:%02d:%02d\n",
+			alm.time.tm_year+1900, alm.time.tm_mon+1, alm.time.tm_mday,
+			alm.time.tm_hour, alm.time.tm_min, alm.time.tm_sec);
+
+		/* read current time */
+		rtc_read_time(rtcdev, &rtc_tm);
+		rtc_tm_to_time(&rtc_tm, &rtc_sec);
+		pr_info("set_sapa: <rtc > %4d-%02d-%02d %02d:%02d:%02d -> %lu\n",
+			rtc_tm.tm_year, rtc_tm.tm_mon, rtc_tm.tm_mday,
+			rtc_tm.tm_hour, rtc_tm.tm_min, rtc_tm.tm_sec, rtc_sec);
+
+		/* calculate offset */
+		set_normalized_timespec(&delta,
+					ktm_ts.tv_sec - rtc_sec,
+					ktm_ts.tv_nsec);
+
+		/* convert user requested SAPA time to second type */
+		rtc_tm_to_time(&alm.time, &rtc_alm_sec);
+
+		/* convert to RTC time with user requested SAPA time and offset */
+		rtc_alm_sec -= delta.tv_sec;
+		if ((alm.enabled % 2) == (rtc_alm_sec % 2)) {
+			rtc_alm_sec++;
+			pr_debug("set_sapa: be adjusted\n");
+		}
+		alm.enabled = 1;
+		rtc_time_to_tm(rtc_alm_sec, &alm.time);
+		pr_info("set_sapa: <alrm> %4d-%02d-%02d %02d:%02d:%02d -> %lu\n",
+			alm.time.tm_year, alm.time.tm_mon, alm.time.tm_mday,
+			alm.time.tm_hour, alm.time.tm_min, alm.time.tm_sec, rtc_alm_sec);
+
+	}
+	ret = rtc_set_bootalarm(rtcdev, &alm);
+	if (ret < 0)
+		pr_err("%s: Failed to set bootalarm\n", __func__);
+
+	return ret;
+}
+#endif /*CONFIG_RTC_AUTO_PWRON*/
+
 static void alarmtimer_rtc_remove_device(struct device *dev,
 				struct class_interface *class_intf)
 {
