--- original/kernel/printk/printk.c	2020-05-07 08:06:22.221183876 +0200
+++ changed/kernel/printk/printk.c	2019-06-03 13:39:53.000000000 +0200
@@ -49,6 +49,13 @@
 
 #include <asm/uaccess.h>
 
+#include <linux/io.h>
+#include <linux/proc_fs.h>
+
+#include <linux/sec_bsp.h>
+#include <linux/sec_debug.h>
+#include <linux/sec_debug_summary.h>
+
 #define CREATE_TRACE_POINTS
 #include <trace/events/printk.h>
 
@@ -230,6 +237,12 @@ struct printk_log {
 #if defined(CONFIG_LOG_BUF_MAGIC)
 	u32 magic;		/* handle for ramdump analysis tools */
 #endif
+#ifdef CONFIG_SEC_DEBUG_PRINTK_NOCACHE
+	char process[16];	/* process Name CONFIG_PRINTK_PROCESS */
+	u16 pid;		/* process id CONFIG_PRINTK_PROCESS */
+	u16 cpu;		/* cpu core number CONFIG_PRINTK_PROCESS */
+	u8 in_interrupt;	/* in interrupt CONFIG_PRINTK_PROCESS */
+#endif
 }
 #ifdef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS
 __packed __aligned(4)
@@ -244,6 +257,10 @@ __packed __aligned(4)
 static DEFINE_RAW_SPINLOCK(logbuf_lock);
 
 #ifdef CONFIG_PRINTK
+#ifdef CONFIG_SEC_DEBUG
+static void sec_log_add(const struct printk_log *msg);
+#endif
+
 DECLARE_WAIT_QUEUE_HEAD(log_wait);
 /* the next printk record to read by syslog(READ) or /proc/kmsg */
 static u64 syslog_seq;
@@ -268,8 +285,48 @@ static enum log_flags console_prev;
 static u64 clear_seq;
 static u32 clear_idx;
 
+/* { SecProductFeature_KNOX.SEC_PRODUCT_FEATURE_KNOX_SUPPORT_MDM - the next printk record to read after the last 'clear_knox' command */
+static u64 clear_seq_knox;
+static u32 clear_idx_knox;
+
+#define SYSLOG_ACTION_READ_CLEAR_KNOX 99
+/* } SecProductFeature_KNOX.SEC_PRODUCT_FEATURE_KNOX_SUPPORT_MDM */
+
+#ifdef CONFIG_SEC_DEBUG
+#define PREFIX_MAX		48
+#else
 #define PREFIX_MAX		32
-#define LOG_LINE_MAX		(1024 - PREFIX_MAX)
+#endif
+
+#define LOG_BUF_SIZE            (1024)
+#define LOG_LINE_MAX		(LOG_BUF_SIZE - PREFIX_MAX)
+
+#ifdef CONFIG_SEC_DEBUG
+/*
+ * Example usage: sec_log=256K@0x45000000
+ *
+ * In above case, log_buf size is 256KB and its physical base address
+ * is 0x45000000. Actually, *(int *)(base - 8) is log_magic and *(int
+ * *)(base - 4) is log_ptr. Therefore we reserve (size + 8) bytes from
+ * (base - 8)
+ */
+#define SEC_LOG_MAGIC 0x4d474f4c /* "LOGM" */
+
+/* These variables are also protected by logbuf_lock */
+static unsigned *sec_log_idx_ptr; /* Log buffer index pointer*/
+static char     *sec_log_buf;
+static unsigned sec_log_size;
+
+#ifdef CONFIG_SEC_DEBUG_PRINTK_NOCACHE
+static phys_addr_t sec_log_buf_paddr;
+
+#ifdef CONFIG_SEC_LOG_LAST_KMSG
+#define LAST_LOG_BUF_SHIFT 19
+static char *last_kmsg_buffer;
+static unsigned last_kmsg_size;
+#endif /* CONFIG_SEC_LOG_LAST_KMSG */
+#endif /* CONFIG_PRINTK_NOCACHE */
+#endif /* CONFIG_SEC_DEBUG */
 
 /* record buffer */
 #define LOG_ALIGN __alignof__(struct printk_log)
@@ -420,7 +477,37 @@ static u32 truncate_msg(u16 *text_len, u
 	return msg_used_size(*text_len + *trunc_msg_len, 0, pad_len);
 }
 
+#if defined(CONFIG_SEC_DEBUG)
+#if defined(CONFIG_SEC_DEBUG_PRINTK_NOCACHE)
+static bool printk_process = 1;
+#else
+static bool printk_process;
+#endif
+#endif
+
 /* insert record into the buffer, discard old ones, update heads */
+#ifndef SZ_128K
+#define SZ_128K                               0x20000
+#endif
+char init_log_buffer[SZ_128K];
+size_t init_log_size = (size_t)SZ_128K;
+static unsigned long buf_idx;
+
+static void sec_debug_hook_init_log(const char *str, u16 size)
+{
+	int len;
+
+	if (buf_idx + size > init_log_size) {
+		len = init_log_size - buf_idx;
+		memcpy(init_log_buffer + buf_idx, str, len);
+		memcpy(init_log_buffer, str + len, size - len);
+		buf_idx = size - len;
+	} else {
+		memcpy(init_log_buffer + buf_idx, str, size);
+		buf_idx = (buf_idx + size) % init_log_size;
+	}
+}
+
 static int log_store(int facility, int level,
 		     enum log_flags flags, u64 ts_nsec,
 		     const char *dict, u16 dict_len,
@@ -456,6 +543,10 @@ static int log_store(int facility, int l
 	/* fill message */
 	msg = (struct printk_log *)(log_buf + log_next_idx);
 	memcpy(log_text(msg), text, text_len);
+	// init task 128K buffer log 
+	if (task_pid_nr(current) == 1)
+		sec_debug_hook_init_log(text, text_len);
+
 	msg->text_len = text_len;
 	if (trunc_msg_len) {
 		memcpy(log_text(msg) + text_len, trunc_msg, trunc_msg_len);
@@ -474,6 +565,18 @@ static int log_store(int facility, int l
 	memset(log_dict(msg) + dict_len, 0, pad_len);
 	msg->len = size;
 
+#ifdef CONFIG_SEC_DEBUG
+	if (printk_process) {
+		strlcpy(msg->process, current->comm, sizeof(msg->process));
+		msg->pid = task_pid_nr(current);
+		msg->cpu = smp_processor_id();
+		msg->in_interrupt = in_interrupt() ? 1 : 0;
+	}
+
+	/* Save the log here,using "msg".*/
+	sec_log_add(msg);
+#endif
+
 	/* insert message */
 	log_next_idx += msg->len;
 	log_next_seq++;
@@ -915,6 +1018,7 @@ void __init setup_log_buf(int early)
 	if (!new_log_buf_len)
 		return;
 
+	set_memsize_kernel_type(MEMSIZE_KERNEL_LOGBUF);
 	if (early) {
 		new_log_buf =
 			memblock_virt_alloc(new_log_buf_len, LOG_ALIGN);
@@ -922,6 +1026,7 @@ void __init setup_log_buf(int early)
 		new_log_buf = memblock_virt_alloc_nopanic(new_log_buf_len,
 							  LOG_ALIGN);
 	}
+	set_memsize_kernel_type(MEMSIZE_KERNEL_OTHERS);
 
 	if (unlikely(!new_log_buf)) {
 		pr_err("log_buf_len: %ld bytes not available\n",
@@ -1031,6 +1136,23 @@ static size_t print_time(u64 ts, char *b
 		       (unsigned long)ts, rem_nsec / 1000);
 }
 
+#ifdef CONFIG_SEC_DEBUG
+static size_t print_process(const struct printk_log *msg, char *buf)
+{
+	if (!printk_process)
+		return 0;
+
+	if (!buf)
+		return snprintf(NULL, 0, "%c[%1d:%15s:%5d] ", ' ', 0, " ", 0);
+
+	return snprintf(buf, __LOG_BUF_LEN, "%c[%1d:%15s:%5d] ",
+					msg->in_interrupt ? 'I' : ' ',
+					msg->cpu,
+					msg->process,
+					msg->pid);
+}
+#endif
+
 static size_t print_prefix(const struct printk_log *msg, bool syslog, char *buf)
 {
 	size_t len = 0;
@@ -1051,6 +1173,10 @@ static size_t print_prefix(const struct
 	}
 
 	len += print_time(msg->ts_nsec, buf ? buf + len : NULL);
+#ifdef CONFIG_SEC_DEBUG
+	len += print_process(msg, buf ? buf + len : NULL);
+#endif
+
 	return len;
 }
 
@@ -1119,7 +1245,7 @@ static int syslog_print(char __user *buf
 	struct printk_log *msg;
 	int len = 0;
 
-	text = kmalloc(LOG_LINE_MAX + PREFIX_MAX, GFP_KERNEL);
+	text = kmalloc(LOG_BUF_SIZE, GFP_KERNEL);
 	if (!text)
 		return -ENOMEM;
 
@@ -1143,7 +1269,7 @@ static int syslog_print(char __user *buf
 		skip = syslog_partial;
 		msg = log_from_idx(syslog_idx);
 		n = msg_print_text(msg, syslog_prev, true, text,
-				   LOG_LINE_MAX + PREFIX_MAX);
+				   LOG_BUF_SIZE);
 		if (n - syslog_partial <= size) {
 			/* message fits into buffer, move forward */
 			syslog_idx = log_next(syslog_idx);
@@ -1177,12 +1303,12 @@ static int syslog_print(char __user *buf
 	return len;
 }
 
-static int syslog_print_all(char __user *buf, int size, bool clear)
+static int syslog_print_all(char __user *buf, int size, bool clear, bool knox)
 {
 	char *text;
 	int len = 0;
 
-	text = kmalloc(LOG_LINE_MAX + PREFIX_MAX, GFP_KERNEL);
+	text = kmalloc(LOG_BUF_SIZE, GFP_KERNEL);
 	if (!text)
 		return -ENOMEM;
 
@@ -1192,19 +1318,33 @@ static int syslog_print_all(char __user
 		u64 seq;
 		u32 idx;
 		enum log_flags prev;
-
-		if (clear_seq < log_first_seq) {
-			/* messages are gone, move to first available one */
-			clear_seq = log_first_seq;
-			clear_idx = log_first_idx;
+		
+		/* { SecProductFeature_KNOX.SEC_PRODUCT_FEATURE_KNOX_SUPPORT_MDM */
+		/* messages are gone, move to first available one */
+		if (!knox && clear_seq < log_first_seq) {
+				clear_seq = log_first_seq;
+				clear_idx = log_first_idx;
+		} else if (knox && clear_seq_knox < log_first_seq) {
+				clear_seq_knox = log_first_seq;
+				clear_idx_knox = log_first_idx;
 		}
+		/* } SecProductFeature_KNOX.SEC_PRODUCT_FEATURE_KNOX_SUPPORT_MDM */
 
 		/*
 		 * Find first record that fits, including all following records,
 		 * into the user-provided buffer for this dump.
 		 */
-		seq = clear_seq;
-		idx = clear_idx;
+		 
+		/* { SecProductFeature_KNOX.SEC_PRODUCT_FEATURE_KNOX_SUPPORT_MDM */ 
+		if(!knox) {
+			seq = clear_seq;
+			idx = clear_idx;
+		}else { //MDM edmaudit
+			seq = clear_seq_knox;
+			idx = clear_idx_knox;
+		}
+		/* } SecProductFeature_KNOX.SEC_PRODUCT_FEATURE_KNOX_SUPPORT_MDM */
+		
 		prev = 0;
 		while (seq < log_next_seq) {
 			struct printk_log *msg = log_from_idx(idx);
@@ -1214,10 +1354,18 @@ static int syslog_print_all(char __user
 			idx = log_next(idx);
 			seq++;
 		}
-
+		
+		/* { SecProductFeature_KNOX.SEC_PRODUCT_FEATURE_KNOX_SUPPORT_MDM */
 		/* move first record forward until length fits into the buffer */
-		seq = clear_seq;
-		idx = clear_idx;
+		if(!knox) {
+			seq = clear_seq;
+			idx = clear_idx;
+		} else { // MDM edmaudit
+			seq = clear_seq_knox;
+			idx = clear_idx_knox;
+		}
+		/* } SecProductFeature_KNOX.SEC_PRODUCT_FEATURE_KNOX_SUPPORT_MDM */
+
 		prev = 0;
 		while (len > size && seq < log_next_seq) {
 			struct printk_log *msg = log_from_idx(idx);
@@ -1237,7 +1385,7 @@ static int syslog_print_all(char __user
 			int textlen;
 
 			textlen = msg_print_text(msg, prev, true, text,
-						 LOG_LINE_MAX + PREFIX_MAX);
+						 LOG_BUF_SIZE);
 			if (textlen < 0) {
 				len = textlen;
 				break;
@@ -1262,10 +1410,18 @@ static int syslog_print_all(char __user
 		}
 	}
 
+	/* { SecProductFeature_KNOX.SEC_PRODUCT_FEATURE_KNOX_SUPPORT_MDM */
 	if (clear) {
-		clear_seq = log_next_seq;
-		clear_idx = log_next_idx;
+		if (!knox) {
+			clear_seq = log_next_seq;
+			clear_idx = log_next_idx;
+		} else { //MDM edmaudit
+			clear_seq_knox = log_next_seq;
+			clear_idx_knox = log_next_idx;
+		}
 	}
+	/* } SecProductFeature_KNOX.SEC_PRODUCT_FEATURE_KNOX_SUPPORT_MDM */
+
 	raw_spin_unlock_irq(&logbuf_lock);
 
 	kfree(text);
@@ -1320,11 +1476,11 @@ int do_syslog(int type, char __user *buf
 			error = -EFAULT;
 			goto out;
 		}
-		error = syslog_print_all(buf, len, clear);
+		error = syslog_print_all(buf, len, clear, false);
 		break;
 	/* Clear ring buffer */
 	case SYSLOG_ACTION_CLEAR:
-		syslog_print_all(NULL, 0, true);
+		syslog_print_all(NULL, 0, true, false);
 		break;
 	/* Disable logging to console */
 	case SYSLOG_ACTION_CONSOLE_OFF:
@@ -1390,6 +1546,21 @@ int do_syslog(int type, char __user *buf
 	case SYSLOG_ACTION_SIZE_BUFFER:
 		error = log_buf_len;
 		break;
+	/* { SecProductFeature_KNOX.SEC_PRODUCT_FEATURE_KNOX_SUPPORT_MDM edmaudit Read last kernel messages */
+	case SYSLOG_ACTION_READ_CLEAR_KNOX:
+		error = -EINVAL;
+		if (!buf || len < 0)
+			goto out;
+		error = 0;
+		if (!len)
+			goto out;
+		if (!access_ok(VERIFY_WRITE, buf, len)) {
+			error = -EFAULT;
+			goto out;
+		}
+		error = syslog_print_all(buf, len, /* clear */ true, /* knox */true);
+		break;
+	/* } SecProductFeature_KNOX.SEC_PRODUCT_FEATURE_KNOX_SUPPORT_MDM */
 	default:
 		error = -EINVAL;
 		break;
@@ -1604,6 +1775,10 @@ static size_t cont_print_text(char *text
 
 	if (cont.cons == 0 && (console_prev & LOG_NEWLINE)) {
 		textlen += print_time(cont.ts_nsec, text);
+#ifdef CONFIG_SEC_DEBUG
+		*(text+textlen) = ' ';
+		textlen += print_process(NULL, NULL);
+#endif
 		size -= textlen;
 	}
 
@@ -1823,6 +1998,220 @@ asmlinkage int printk_emit(int facility,
 }
 EXPORT_SYMBOL(printk_emit);
 
+#ifdef CONFIG_SEC_DEBUG
+unsigned int get_sec_log_idx(void)
+{
+	return *sec_log_idx_ptr;
+}
+EXPORT_SYMBOL(get_sec_log_idx);
+
+static inline void emit_sec_log_char(char c)
+{
+	sec_log_buf[*sec_log_idx_ptr % sec_log_size] = c;
+	(*sec_log_idx_ptr)++;
+}
+
+static void sec_log_add(const struct printk_log *msg)
+{
+	static char tmp[LOG_BUF_SIZE];
+	static unsigned char prev_flag;
+	size_t size = 0;
+	int i;
+
+	if (!sec_log_buf || !sec_log_idx_ptr)
+		return;
+
+	size = msg_print_text(msg, prev_flag, true, tmp, LOG_BUF_SIZE);
+	prev_flag = msg->flags;
+	for (i = 0; i < size; i++)
+		emit_sec_log_char(tmp[i]);
+}
+
+static void sec_log_add_on_bootup(void)
+{
+	u32 current_idx = log_first_idx;
+	struct printk_log *msg;
+
+	while (current_idx < log_next_idx) {
+		msg = log_from_idx(current_idx);
+		sec_log_add(msg);
+		current_idx = log_next(current_idx);
+	}
+}
+
+#ifdef CONFIG_SEC_DEBUG_SUMMARY
+void sec_debug_summary_set_kloginfo(uint64_t *first_idx_paddr,
+	uint64_t *next_idx_paddr, uint64_t *log_paddr, uint64_t *size)
+{
+	*first_idx_paddr = (unsigned int)__pa(&log_first_idx);
+	*next_idx_paddr = (unsigned int)__pa(&log_next_idx);
+	*log_paddr = (unsigned int)__pa(log_buf);
+	*size = __LOG_BUF_LEN;
+}
+#endif
+
+#ifdef CONFIG_SEC_LOG_LAST_KMSG
+static int __init sec_log_save_old(void)
+{
+	/* provide previous log as last_kmsg */
+	last_kmsg_size =
+		min((unsigned)(1 << LAST_LOG_BUF_SHIFT), *sec_log_idx_ptr);
+
+	last_kmsg_buffer = kmalloc(last_kmsg_size, GFP_KERNEL);
+
+	if (last_kmsg_size && last_kmsg_buffer && sec_log_buf) {
+		unsigned int i;
+		for (i = 0; i < last_kmsg_size; i++)
+			last_kmsg_buffer[i] = sec_log_buf[
+				(*sec_log_idx_ptr - last_kmsg_size + i)
+				% sec_log_size];
+		return 1;
+	}
+
+	return 0;
+}
+#else
+static int __init sec_log_save_old(void)
+{
+	return 1;
+}
+#endif
+
+#ifdef CONFIG_SEC_DEBUG_PRINTK_NOCACHE
+/* This function remap the given address to sec_log buffer.*/
+static int __init printk_remap_nocache(void)
+{
+	void __iomem *nocache_base;
+	unsigned *sec_log_mag;
+	unsigned long flags;
+	int rc = 0;
+	int bOk = 0;
+
+	sec_getlog_supply_kloginfo(log_buf);
+	nocache_base = ioremap_nocache((phys_addr_t)(sec_log_buf_paddr),
+					sec_log_size);
+
+	if (!nocache_base) {
+		pr_err("Failed to remap nocache log region\n");
+		return rc;
+	}
+
+	pr_err("%s: nocache_base printk virtual addrs 0x%p phy=0x%llx \n",
+		__func__, nocache_base, (uint64_t)sec_log_buf_paddr);
+
+	sec_log_mag = nocache_base + 0x8;
+	sec_log_idx_ptr = nocache_base + 0xc;
+	sec_log_buf = nocache_base + 0x10;
+	sec_log_size -= 0x10;
+
+	if (*sec_log_mag != SEC_LOG_MAGIC) {
+		pr_err("%s:sec_log_magic is not valid : 0x%x at 0x%p\n"
+				,__func__,*sec_log_mag, sec_log_mag);
+		*sec_log_idx_ptr = 0;
+		*sec_log_mag = SEC_LOG_MAGIC;
+	} else {
+		bOk = sec_log_save_old();
+	}
+
+	raw_spin_lock_irqsave(&logbuf_lock, flags);
+
+	/*We have to save logs printed prior to the sec log initialization here.*/
+	sec_log_add_on_bootup();
+
+	raw_spin_unlock_irqrestore(&logbuf_lock, flags);
+
+#ifdef CONFIG_SEC_LOG_LAST_KMSG
+	if (bOk) {
+		pr_info("%s: saved old log at %d@%p\n",
+			__func__, last_kmsg_size, last_kmsg_buffer);
+	} else {
+		pr_err("%s: failed saving old log \n",__func__);
+	}
+#endif
+	return rc;
+}
+
+static ssize_t seclog_read(struct file *file, char __user *buf,
+				    size_t len, loff_t *offset)
+{
+	loff_t pos = *offset;
+	ssize_t count = 0;
+#ifdef CONFIG_SEC_LOG_LAST_KMSG
+	size_t log_size = last_kmsg_size;
+	const char *log = last_kmsg_buffer;
+#else
+	size_t log_size = sec_log_size;
+	const char *log = sec_log_buf;
+#endif
+
+	if (pos < log_size) {
+		count = min(len, (size_t)(log_size - pos));
+		if (copy_to_user(buf, log + pos, count))
+			return -EFAULT;
+	}
+
+	*offset += count;
+	return count;
+}
+
+static const struct file_operations seclog_file_ops = {
+	.owner = THIS_MODULE,
+	.read = seclog_read,
+};
+static int __init seclog_late_init(void)
+{
+	struct proc_dir_entry *entry;
+
+	if (!sec_log_buf)
+		return 0;
+
+	/* The reason we are using the file name "last_kmsg" is only
+	 * because the dumpstate app is dumping this file.
+	 * If we add a line in the dumpstate app (and we should change
+	 * the owner and permission in init.rc) with a new name, then
+	 * we can use a more appropriate name. (But the purpose of
+	 * last_kmsg and this file are almost the same, so the name isn't
+	 * that odd) */
+	entry = proc_create_data("last_kmsg", S_IFREG | S_IRUGO,
+			NULL, &seclog_file_ops, NULL);
+	if (!entry) {
+		pr_err("%s: failed to create proc entry. ", __func__);
+		pr_err("ram console may be present.\n");
+		return 0;
+	}
+
+#ifdef CONFIG_SEC_LOG_LAST_KMSG
+	proc_set_size(entry, last_kmsg_size);
+#else
+	proc_set_size(entry, sec_log_size);
+#endif
+	return 0;
+}
+late_initcall(seclog_late_init);
+#endif
+
+static int __init sec_log_setup(char *str)
+{
+	unsigned size = memparse(str, &str);
+	int ret;
+
+	if (size && (size == roundup_pow_of_two(size)) && (*str == '@')) {
+		unsigned long long base = 0;
+
+		ret = kstrtoull(++str, 0, &base);
+
+#ifdef CONFIG_SEC_DEBUG_PRINTK_NOCACHE
+		sec_log_buf_paddr = base;
+		sec_log_size = size;
+#endif
+	}
+	return 1;
+}
+
+__setup("sec_log=", sec_log_setup);
+
+#endif
+
 /**
  * printk - print a kernel message
  * @fmt: format string
@@ -1987,6 +2376,10 @@ static int __init console_setup(char *st
 
 	__add_preferred_console(buf, idx, options, brl_options);
 	console_set_on_cmdline = 1;
+
+	if (strcmp(buf, "null"))
+		sec_bsp_enable_console();
+
 	return 1;
 }
 __setup("console=", console_setup);
@@ -2202,7 +2595,7 @@ out:
  */
 void console_unlock(void)
 {
-	static char text[LOG_LINE_MAX + PREFIX_MAX];
+	static char text[LOG_BUF_SIZE];
 	static u64 seen_seq;
 	unsigned long flags;
 	bool wake_klogd = false;
@@ -3087,6 +3480,9 @@ void __init dump_stack_set_arch_desc(con
 	vsnprintf(dump_stack_arch_desc_str, sizeof(dump_stack_arch_desc_str),
 		  fmt, args);
 	va_end(args);
+#ifdef CONFIG_SEC_DEBUG_SUMMARY
+	sec_debug_arch_desc = (char *)dump_stack_arch_desc_str;
+#endif
 }
 
 /**
@@ -3127,4 +3523,8 @@ void show_regs_print_info(const char *lo
 	       task_thread_info(current));
 }
 
+#ifdef CONFIG_SEC_DEBUG_PRINTK_NOCACHE
+subsys_initcall(printk_remap_nocache);
+#endif
+
 #endif
