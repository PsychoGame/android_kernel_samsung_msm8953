--- original/drivers/hid/uhid.c	2020-05-07 08:31:23.009812223 +0200
+++ changed/drivers/hid/uhid.c	2019-06-03 13:39:50.000000000 +0200
@@ -24,6 +24,7 @@
 #include <linux/spinlock.h>
 #include <linux/uhid.h>
 #include <linux/wait.h>
+#include <linux/fb.h>
 
 #define UHID_NAME	"uhid"
 #define UHID_BUFSIZE	32
@@ -72,6 +73,7 @@ static void uhid_device_add_worker(struc
 		uhid->running = false;
 	}
 }
+bool lcd_is_on = true;
 
 static void uhid_queue(struct uhid_device *uhid, struct uhid_event *ev)
 {
@@ -190,7 +192,7 @@ static int __uhid_report_queue_and_wait(
 
 	ret = wait_event_interruptible_timeout(uhid->report_wait,
 				!uhid->report_running || !uhid->running,
-				5 * HZ);
+				10/*5 * HZ*/);  // from 5000 to 10 due to BT stuck when connecting apple magic mouse during a2dp playing
 	if (!ret || !uhid->running || uhid->report_running)
 		ret = -EIO;
 	else if (ret < 0)
@@ -793,13 +795,43 @@ static struct miscdevice uhid_misc = {
 	.name		= UHID_NAME,
 };
 
+static int fb_state_change(struct notifier_block *nb,
+    unsigned long val, void *data)
+{
+	struct fb_event *evdata = data;
+	unsigned int blank;
+    dbg_hid("fb_state_change");
+	if (val != FB_EVENT_BLANK)
+		return 0;
+
+	blank = *(int *)evdata->data;
+
+	switch (blank) {
+	case FB_BLANK_POWERDOWN:
+		lcd_is_on = false;
+		break;
+	case FB_BLANK_UNBLANK:
+		lcd_is_on = true;
+		break;
+	default:
+		break;
+	}
+
+	return NOTIFY_OK;
+}
+static struct notifier_block fb_block = {
+    .notifier_call = fb_state_change,
+};
+
 static int __init uhid_init(void)
 {
+	fb_register_client(&fb_block);
 	return misc_register(&uhid_misc);
 }
 
 static void __exit uhid_exit(void)
 {
+	fb_unregister_client(&fb_block);
 	misc_deregister(&uhid_misc);
 }
 
