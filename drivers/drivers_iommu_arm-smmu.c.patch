--- original/drivers/iommu/arm-smmu.c	2020-05-07 08:31:23.383808858 +0200
+++ changed/drivers/iommu/arm-smmu.c	2019-06-03 13:39:50.000000000 +0200
@@ -54,6 +54,10 @@
 
 #include "io-pgtable.h"
 
+#ifdef CONFIG_USER_RESET_DEBUG
+#include <linux/user_reset/sec_debug_user_reset.h>
+#endif
+
 /* Maximum number of stream IDs assigned to a single device */
 #define MAX_MASTER_STREAMIDS		45
 
@@ -1226,6 +1230,11 @@ static irqreturn_t arm_smmu_context_faul
 				      DEFAULT_RATELIMIT_INTERVAL,
 				      DEFAULT_RATELIMIT_BURST);
 
+
+#ifdef CONFIG_USER_RESET_DEBUG
+	ex_info_smmu_t sec_dbg_smmu; 
+#endif
+
 	mutex_lock(&smmu_domain->init_mutex);
 	smmu = smmu_domain->smmu;
 	if (!smmu) {
@@ -1254,6 +1263,14 @@ static irqreturn_t arm_smmu_context_faul
 	if (fatal_asf && (fsr & FSR_ASF)) {
 		dev_err(smmu->dev,
 			"Took an address size fault.  Refusing to recover.\n");
+#ifdef CONFIG_USER_RESET_DEBUG
+		snprintf(sec_dbg_smmu.dev_name, sizeof(sec_dbg_smmu.dev_name),
+				"%s", dev_name(smmu->dev));
+		sec_dbg_smmu.fsr = fsr;
+
+		sec_debug_save_smmu_info(&sec_dbg_smmu);
+#endif
+
 		BUG();
 	}
 
@@ -1322,6 +1339,21 @@ static irqreturn_t arm_smmu_context_faul
 		if (!non_fatal_fault) {
 			dev_err(smmu->dev,
 				"Unhandled context faults are fatal on this domain. Going down now...\n");
+
+#ifdef CONFIG_USER_RESET_DEBUG
+			snprintf(sec_dbg_smmu.dev_name, sizeof(sec_dbg_smmu.dev_name),
+					"%s", dev_name(smmu->dev));
+			sec_dbg_smmu.fsr = fsr;
+			sec_dbg_smmu.fsynr = fsynr;
+			sec_dbg_smmu.iova = iova;
+			sec_dbg_smmu.cbndx = cfg->cbndx;
+			sec_dbg_smmu.phys_soft = phys_soft;
+			sec_dbg_smmu.phys_atos = phys_atos;
+			sec_dbg_smmu.sid = frsynra & 0xffff;
+
+			sec_debug_save_smmu_info(&sec_dbg_smmu);
+#endif
+
 			BUG();
 		}
 	}
