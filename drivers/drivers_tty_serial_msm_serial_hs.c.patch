--- original/drivers/tty/serial/msm_serial_hs.c	2020-05-07 08:31:25.775787339 +0200
+++ changed/drivers/tty/serial/msm_serial_hs.c	2019-06-03 13:39:52.000000000 +0200
@@ -254,6 +254,7 @@ struct msm_hs_port {
 	struct pinctrl_state *gpio_state_suspend;
 	bool flow_control;
 	enum msm_hs_pm_state pm_state;
+	enum msm_hs_pm_state prev_pm_state;
 	atomic_t client_count;
 	bool obs; /* out of band sleep flag */
 	atomic_t client_req_state;
@@ -411,7 +412,7 @@ static void msm_hs_resource_vote(struct
 	struct uart_port *uport = &(msm_uport->uport);
 	ret = pm_runtime_get_sync(uport->dev);
 	if (ret < 0 || msm_uport->pm_state != MSM_HS_PM_ACTIVE) {
-		MSM_HS_WARN("%s:%s runtime callback not invoked ret:%d st:%d",
+		MSM_HS_WARN("%s:%s runtime callback not invoked ret:%d st:%d\n",
 			__func__, dev_name(uport->dev), ret,
 					msm_uport->pm_state);
 		msm_hs_pm_resume(uport->dev);
@@ -2734,6 +2735,10 @@ static int msm_hs_startup(struct uart_po
 	spin_unlock_irqrestore(&uport->lock, flags);
 
 	msm_hs_resource_unvote(msm_uport);
+
+	/* enable clock (runtime suspend doen't work during holding the clock */
+	msm_hs_request_clock_on(uport);
+
 	return 0;
 
 sps_disconnect_rx:
@@ -2894,6 +2899,8 @@ struct msm_serial_hs_platform_data
 		return ERR_PTR(-EINVAL);
 	}
 
+	pdata->unuse_pm = of_property_read_bool(node, "qcom,unuse-pm");
+
 	pr_debug("tx_ep_pipe_index:%d rx_ep_pipe_index:%d\n"
 		"tx_gpio:%d rx_gpio:%d rfr_gpio:%d cts_gpio:%d",
 		pdata->bam_tx_ep_pipe_index, pdata->bam_rx_ep_pipe_index,
@@ -3142,7 +3149,7 @@ static void obs_manage_irq(struct msm_hs
 	}
 }
 
-static void msm_hs_pm_suspend(struct device *dev)
+static int _msm_hs_pm_suspend(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct msm_hs_port *msm_uport = get_matching_hs_port(pdev);
@@ -3174,13 +3181,25 @@ static void msm_hs_pm_suspend(struct dev
 		"%s: PM State Suspended client_count %d\n", __func__,
 								client_count);
 	mutex_unlock(&msm_uport->mtx);
-	return;
+	return 0;
 err_suspend:
 	pr_err("%s(): invalid uport", __func__);
-	return;
+	return 0;
 }
 
-static int msm_hs_pm_resume(struct device *dev)
+static int msm_hs_pm_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct msm_hs_port *msm_uport = get_matching_hs_port(pdev);
+
+	msm_uport->prev_pm_state = msm_uport->pm_state;
+	if (msm_uport->prev_pm_state == MSM_HS_PM_ACTIVE)
+		return _msm_hs_pm_suspend(dev);
+
+	return 0;
+}
+
+static int _msm_hs_pm_resume(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct msm_hs_port *msm_uport = get_matching_hs_port(pdev);
@@ -3225,6 +3244,17 @@ exit_pm_resume:
 	return ret;
 }
 
+static int msm_hs_pm_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct msm_hs_port *msm_uport = get_matching_hs_port(pdev);
+
+	if (msm_uport->prev_pm_state == MSM_HS_PM_ACTIVE)
+		return _msm_hs_pm_resume(dev);
+
+	return 0;
+}
+
 #ifdef CONFIG_PM
 static int msm_hs_pm_sys_suspend_noirq(struct device *dev)
 {
@@ -3295,19 +3325,19 @@ static void  msm_serial_hs_rt_init(struc
 	pm_runtime_use_autosuspend(uport->dev);
 	mutex_lock(&msm_uport->mtx);
 	msm_uport->pm_state = MSM_HS_PM_SUSPENDED;
+	msm_uport->prev_pm_state = MSM_HS_PM_SUSPENDED;
 	mutex_unlock(&msm_uport->mtx);
 	pm_runtime_enable(uport->dev);
 }
 
 static int msm_hs_runtime_suspend(struct device *dev)
 {
-	msm_hs_pm_suspend(dev);
-	return 0;
+	return _msm_hs_pm_suspend(dev);
 }
 
 static int msm_hs_runtime_resume(struct device *dev)
 {
-	return msm_hs_pm_resume(dev);
+	return _msm_hs_pm_resume(dev);
 }
 #else
 static void  msm_serial_hs_rt_init(struct uart_port *uport) {}
@@ -3649,6 +3679,9 @@ static void msm_hs_shutdown(struct uart_
 	int data;
 	unsigned long flags;
 
+	/* disable clock */
+	msm_hs_request_clock_off(uport);
+
 	if (is_use_low_power_wakeup(msm_uport))
 		irq_set_irq_wake(msm_uport->wakeup.irq, 0);
 
@@ -3759,6 +3792,8 @@ static const struct dev_pm_ops msm_hs_de
 	.runtime_idle = NULL,
 	.suspend_noirq = msm_hs_pm_sys_suspend_noirq,
 	.resume_noirq = msm_hs_pm_sys_resume_noirq,
+	.suspend = msm_hs_pm_suspend,
+	.resume = msm_hs_pm_resume,
 };
 
 static struct platform_driver msm_serial_hs_platform_driver = {
