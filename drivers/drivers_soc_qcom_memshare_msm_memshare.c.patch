--- original/drivers/soc/qcom/memshare/msm_memshare.c	2020-05-07 08:31:25.294791665 +0200
+++ changed/drivers/soc/qcom/memshare/msm_memshare.c	2019-06-03 13:39:52.000000000 +0200
@@ -24,6 +24,12 @@
 #include <soc/qcom/scm.h>
 #include "msm_memshare.h"
 #include "heap_mem_ext_v01.h"
+#ifdef CONFIG_SEC_BSP
+#include <linux/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <soc/qcom/secure_buffer.h>
+#endif
 
 #include <soc/qcom/secure_buffer.h>
 #include <soc/qcom/ramdump.h>
@@ -40,6 +46,7 @@ static struct workqueue_struct *mem_shar
 static uint64_t bootup_request;
 static bool ramdump_event;
 static void *memshare_ramdump_dev[MAX_CLIENTS];
+static struct device *memshare_dev[MAX_CLIENTS];
 
 /* Memshare Driver Structure */
 struct memshare_driver {
@@ -47,6 +54,9 @@ struct memshare_driver {
 	struct mutex mem_share;
 	struct mutex mem_free;
 	struct work_struct memshare_init_work;
+#ifdef CONFIG_SEC_BSP
+	struct memshare_rd_device *memshare_rd_dev;
+#endif
 };
 
 struct memshare_child {
@@ -128,13 +138,32 @@ static struct msg_desc mem_share_svc_siz
 static int mem_share_configure_ramdump(void)
 {
 	char client_name[18] = "memshare_";
-	char *clnt;
+	char *clnt = NULL;
 
-	clnt = ((!num_clients) ? "GPS" : ((num_clients == 1) ? "FTM" : "DIAG"));
-	snprintf(client_name, 18, "memshare_%s", clnt);
+	switch (num_clients) {
+	case 0:
+		clnt = "GPS";
+		break;
+	case 1:
+		clnt = "FTM";
+		break;
+	case 2:
+		clnt = "DIAG";
+		break;
+	default:
+		pr_info("memshare: no memshare clients registered\n");
+		return -EINVAL;
+	}
 
-	memshare_ramdump_dev[num_clients] = create_ramdump_device(client_name,
-								NULL);
+	snprintf(client_name, 18, "memshare_%s", clnt);
+	if (memshare_dev[num_clients]) {
+		memshare_ramdump_dev[num_clients] =
+			create_ramdump_device(client_name,
+				memshare_dev[num_clients]);
+	} else {
+		pr_err("memshare:%s: invalid memshare device\n", __func__);
+		return -ENODEV;
+	}
 	if (IS_ERR_OR_NULL(memshare_ramdump_dev[num_clients])) {
 		pr_err("memshare: %s: Unable to create memshare ramdump device.\n",
 				__func__);
@@ -145,6 +174,219 @@ static int mem_share_configure_ramdump(v
 	return 0;
 }
 
+#ifdef CONFIG_SEC_BSP
+struct memshare_rd_device {
+	char name[256];
+	struct miscdevice device;
+	unsigned long address;
+	void *v_address;
+	unsigned long size;
+	unsigned int data_ready;	
+	struct dma_attrs attrs;
+};
+
+static void memshare_set_nhlos_permission(phys_addr_t addr, u32 size)
+{
+	int ret;
+	u32 source_vmlist[1] = {VMID_HLOS};
+	int dest_vmids[2] = {VMID_MSS_MSA, VMID_HLOS};
+	int dest_perms[2] = {PERM_READ|PERM_WRITE, PERM_READ|PERM_WRITE};
+
+	if (!size || !addr) {
+		pr_err("%s: Unable to handle addr(0x%llx), size(%d)", 
+			__func__, (uint64_t)addr, size);
+		return;
+	}
+
+	ret = hyp_assign_phys(addr, size, source_vmlist, 1, dest_vmids, 
+				dest_perms, 2);
+
+	pr_info("%s: hyp_assign_phys called addr(0x%llx) size(%d)  ret:%d\n", 
+					__func__, (uint64_t)addr, size, ret);
+
+	if (ret != 0) {
+		if (ret == -ENOSYS)
+			pr_warn("hyp_assign_phys is not supported!");
+		else
+			pr_err("hyp_assign_phys failed IPA=0x016%pa size=%u err=%d\n",
+				&addr, size, ret);
+	}
+}
+
+static void memshare_unset_nhlos_permission(phys_addr_t addr, u32 size)
+{
+	int ret;
+	u32 source_vmlist[2] = {VMID_MSS_MSA, VMID_HLOS};
+	int dest_vmids[1] = {VMID_HLOS};
+	int dest_perms[1] = {PERM_READ|PERM_WRITE|PERM_EXEC};
+
+	if (!size || !addr) {
+		pr_err("%s: Unable to handle addr(0x%llx), size(%d)", 
+			__func__, (uint64_t)addr, size);
+		return;
+	}
+
+	ret = hyp_assign_phys(addr, size, source_vmlist, 2, dest_vmids, 
+				dest_perms, 1);
+
+	pr_info("%s: hyp_assign_phys called addr(0x%llx) size(%d)  ret:%d\n", 
+					__func__, (uint64_t)addr, size, ret);
+
+	if (ret != 0) {
+		if (ret == -ENOSYS)
+			pr_warn("hyp_assign_phys is not supported!");
+		else
+			pr_err("hyp_assign_phys failed IPA=0x016%pa size=%u err=%d\n",
+				&addr, size, ret);
+	}
+}
+
+static int memshare_rd_open(struct inode *inode, struct file *filep)
+{
+	return 0;
+}
+
+static int memshare_rd_release(struct inode *inode, struct file *filep)
+{
+	return 0;
+}
+
+static ssize_t memshare_rd_read(struct file *filep, char __user *buf, 
+				size_t count, loff_t *pos)
+{
+	struct memshare_rd_device *rd_dev = container_of(filep->private_data,
+				struct memshare_rd_device, device);
+	void *device_mem = NULL;
+	unsigned long data_left = 0;
+	unsigned long addr = 0;
+	unsigned long copy_size = 0;
+	int ret = 0;
+
+	if ((filep->f_flags & O_NONBLOCK) && !rd_dev->data_ready)
+		return -EAGAIN;
+
+	data_left = rd_dev->size - *pos;
+	addr = rd_dev->address + *pos; 
+
+	/* EOF check */
+	if (data_left == 0) {
+		pr_info("%s(%s): Ramdump complete. %zu bytes read.", __func__,
+			rd_dev->name, (size_t)*pos);
+		ret = 0;
+		goto ramdump_done;
+	}
+
+#ifdef __aarch64__
+	copy_size = min(count, (unsigned long)SZ_1M);
+#else
+	copy_size = min(count, (unsigned int)SZ_1M);
+#endif
+	copy_size = min(copy_size, data_left);
+	device_mem = ioremap_nocache(addr, copy_size);
+
+	if (device_mem == NULL) {
+		pr_err("%s(%s): Unable to ioremap: addr %lx, copy_size %lu\n", __func__,
+			rd_dev->name, addr, copy_size);
+		ret = -ENOMEM;
+		goto ramdump_done;
+	}
+
+	pr_debug("%s:copy_to_user(buf:%pK, p_addr:%lx, device_mem :%pK, copy_size :%lu\n",
+			__func__, buf, addr, device_mem, copy_size);
+
+	if (copy_to_user(buf, device_mem, copy_size)) {
+		pr_err("%s(%s): Couldn't copy all data to user.", __func__,
+			rd_dev->name);
+		iounmap(device_mem);
+		ret = -EFAULT;
+		goto ramdump_done;
+	}
+
+	iounmap(device_mem);
+	*pos += copy_size;
+
+	pr_debug("%s(%s): Read %lu bytes from address %lx.", __func__,
+			rd_dev->name, copy_size, addr);
+
+	return copy_size;
+
+ramdump_done:
+	*pos = 0;
+	return ret;
+}
+
+static const struct file_operations memshare_rd_file_ops = {
+	.open = memshare_rd_open,
+	.release = memshare_rd_release,
+	.read = memshare_rd_read
+};
+
+static void *create_memshare_rd_device(const char *dev_name, 
+											struct device *parent)
+{
+	int ret;
+	struct memshare_rd_device *rd_dev;
+
+	if (!dev_name) {
+		pr_err("%s: Invalid device name.\n", __func__);
+		return NULL;
+	}
+
+	rd_dev = kzalloc(sizeof(struct memshare_rd_device), GFP_KERNEL);
+
+	if (!rd_dev) {
+		pr_err("%s: Couldn't alloc space for ramdump device!",
+			__func__);
+		return NULL;
+	}
+
+	snprintf(rd_dev->name, ARRAY_SIZE(rd_dev->name), "ramdump_%s",
+		 dev_name);
+
+	rd_dev->device.minor = MISC_DYNAMIC_MINOR;
+	rd_dev->device.name = rd_dev->name;
+	rd_dev->device.fops = &memshare_rd_file_ops;
+	rd_dev->device.parent = parent;
+
+	ret = misc_register(&rd_dev->device);
+
+	if (ret) {
+		pr_err("%s: misc_register failed for %s (%d)", __func__,
+				dev_name, ret);
+		kfree(rd_dev);
+		return NULL;
+	}
+
+	return (void *)rd_dev;
+}
+
+static void destroy_memshare_rd_device(void *dev)
+{
+	struct memshare_rd_device *rd_dev = dev;
+
+	if (IS_ERR_OR_NULL(rd_dev))
+		return ;
+
+	misc_deregister(&rd_dev->device);
+	kfree(rd_dev);
+} 
+
+static int memshare_rd_set(struct memshare_rd_device *rd_dev,
+		phys_addr_t p_addr, unsigned long size, void *v_addr)
+{
+	int rc = 0;
+
+	rd_dev->address = p_addr;
+	rd_dev->v_address = v_addr;
+	rd_dev->size = size;
+	rd_dev->data_ready = 1;
+
+	pr_debug("%s: p_addr(%llx), size(%lu)\n", __func__, (uint64_t)p_addr, size);
+
+	return rc;
+}
+#endif
+
 static int check_client(int client_id, int proc, int request)
 {
 	int i = 0, rc;
@@ -157,7 +399,11 @@ static int check_client(int client_id, i
 			break;
 		}
 	}
-	if ((found == DHMS_MEM_CLIENT_INVALID) && !request) {
+
+	if ((found == DHMS_MEM_CLIENT_INVALID) && client_id == 3) {
+		pr_err("memshare: client_id 3(CP RAM logging) disabled.\n");
+	}
+	else if ((found == DHMS_MEM_CLIENT_INVALID) && !request) {
 		pr_debug("memshare: No registered client, adding a new client\n");
 		/* Add a new client */
 		for (i = 0; i < MAX_CLIENTS; i++) {
@@ -234,6 +480,7 @@ void initialize_client(void)
 		memblock[i].file_created = 0;
 	}
 	dma_set_attr(DMA_ATTR_NO_KERNEL_MAPPING, &attrs);
+	dma_set_attr(DMA_ATTR_SKIP_ZEROING, &attrs);
 }
 
 /*
@@ -248,14 +495,26 @@ void initialize_client(void)
 static int mem_share_do_ramdump(void)
 {
 	int i = 0, ret;
-	char *client_name;
+	char *client_name = NULL;
 
 	for (i = 0; i < num_clients; i++) {
 
 		struct ramdump_segment *ramdump_segments_tmp = NULL;
 
-		client_name = (i == 0) ? "GPS" :
-			((i == 1) ? "FTM" : ((i == 2) ? "DIAG" : "NULL"));
+		switch (i) {
+		case 0:
+			client_name = "GPS";
+			break;
+		case 1:
+			client_name = "FTM";
+			break;
+		case 2:
+			client_name = "DIAG";
+			break;
+		default:
+			pr_info("memshare: no memshare clients registered\n");
+			break;
+		}
 
 		if (!memblock[i].alloted) {
 			pr_err("memshare:%s memblock is not alloted\n",
@@ -295,7 +554,7 @@ static int modem_notifier_cb(struct noti
 	int ret;
 	u32 source_vmlist[2] = {VMID_HLOS, VMID_MSS_MSA};
 	int dest_vmids[1] = {VMID_HLOS};
-	int dest_perms[1] = {PERM_READ|PERM_WRITE};
+	int dest_perms[1] = {PERM_READ|PERM_WRITE|PERM_EXEC};
 	struct notif_data *notifdata = NULL;
 
 	mutex_lock(&memsh_drv->mem_share);
@@ -378,6 +637,15 @@ static int modem_notifier_cb(struct noti
 		bootup_request++;
 		break;
 
+#ifdef CONFIG_SEC_BSP
+	case SUBSYS_AFTER_SHUTDOWN:
+		pr_err("memshare: Modem shutdown has happened\n");
+//		memshare_unset_nhlos_permission(memsh_drv->memshare_rd_dev->address,
+//				memsh_drv->memshare_rd_dev->size);
+		memsh_drv->memshare_rd_dev->data_ready = 0;
+		break;
+#endif
+
 	default:
 		pr_debug("Memshare: code: %lu\n", code);
 		break;
@@ -414,6 +682,10 @@ static void shared_hyp_mapping(int clien
 				memblock[client_id].size, ret);
 		return;
 	}
+
+	pr_info("memshare: %s, hyp_assign_phys called addr(0x%llx) size(%d)  ret:%d\n", 
+					__func__, (uint64_t)memblock[client_id].phy_addr, memblock[client_id].size, ret);
+	
 	memblock[client_id].hyp_mapping = 1;
 }
 
@@ -441,12 +713,20 @@ static int handle_alloc_req(void *req_h,
 		alloc_resp.resp = QMI_RESULT_FAILURE_V01;
 		memblock[GPS].size = 0;
 	} else {
+#ifdef CONFIG_SEC_BSP
+		memshare_set_nhlos_permission(memblock[GPS].phy_addr,
+				alloc_req->num_bytes);
+		memshare_rd_set(memsh_drv->memshare_rd_dev, memblock[GPS].phy_addr,
+				alloc_req->num_bytes, memblock[GPS].virtual_addr);
+		memblock[GPS].alloted = 1;
+		memblock[GPS].size = alloc_req->num_bytes;
+#endif
 		alloc_resp.resp = QMI_RESULT_SUCCESS_V01;
 	}
 
 	mutex_unlock(&memsh_drv->mem_share);
 
-	pr_debug("alloc_resp.num_bytes :%d, alloc_resp.handle :%lx, alloc_resp.mem_req_result :%lx\n",
+	pr_info("alloc_resp.num_bytes :%d, alloc_resp.handle :%lx, alloc_resp.mem_req_result :%lx\n",
 			  alloc_resp.num_bytes,
 			  (unsigned long int)alloc_resp.handle,
 			  (unsigned long int)alloc_resp.resp);
@@ -486,29 +766,47 @@ static int handle_alloc_generic_req(void
 		pr_err("memshare: %s client not found, requested client: %d, proc_id: %d\n",
 				__func__, alloc_req->client_id,
 				alloc_req->proc_id);
-		kfree(alloc_resp);
-		alloc_resp = NULL;
-		return -EINVAL;
+		//kfree(alloc_resp);
+		//alloc_resp = NULL;
+		//return -EINVAL;
+		client_id = alloc_req->client_id;
+		resp = 1;
 	}
-
-	memblock[client_id].free_memory += 1;
-	pr_debug("memshare: In %s, free memory count for client id: %d = %d",
-		__func__, memblock[client_id].client_id,
-			memblock[client_id].free_memory);
-	if (!memblock[client_id].alloted) {
-		rc = memshare_alloc(memsh_drv->dev, alloc_req->num_bytes,
-					&memblock[client_id]);
-		if (rc) {
-			pr_err("In %s,Unable to allocate memory for requested client\n",
-							__func__);
-			resp = 1;
+	else {
+		if (!memblock[client_id].alloted) {
+			rc = memshare_alloc(memsh_drv->dev, alloc_req->num_bytes,
+						&memblock[client_id]);
+			if (rc) {
+				pr_err("In %s,Unable to allocate memory for requested client\n",
+								__func__);
+				resp = 1;
+			}
 		}
-		if (!resp) {
-			memblock[client_id].alloted = 1;
-			memblock[client_id].size = alloc_req->num_bytes;
-			memblock[client_id].peripheral = alloc_req->proc_id;
+		else {
+			if (memblock[client_id].size < alloc_req->num_bytes)
+			{
+				pr_err("In %s,guarantee memory size (0x%x) is smaller than alloc request (0x%x)\n",
+				__func__, memblock[client_id].size, alloc_req->num_bytes);
+				resp = 1;
+			}
+		}
+	}
+	
+	if (!resp) {
+		memblock[client_id].free_memory += 1;
+		memblock[client_id].alloted = 1;
+		memblock[client_id].size = alloc_req->num_bytes;
+		memblock[client_id].peripheral = alloc_req->proc_id;
+#ifdef CONFIG_SEC_BSP
+		if(client_id == 3)	{ //only for client 3, CP ram logging
+			memshare_rd_set(memsh_drv->memshare_rd_dev, memblock[client_id].phy_addr,
+					alloc_req->num_bytes, memblock[client_id].virtual_addr);
 		}
+#endif
 	}
+	pr_debug("memshare: In %s, free memory count for client id: %d = %d",
+		__func__, memblock[client_id].client_id,
+			memblock[client_id].free_memory);
 	memblock[client_id].sequence_id = alloc_req->sequence_id;
 
 	fill_alloc_response(alloc_resp, client_id, &resp);
@@ -516,11 +814,11 @@ static int handle_alloc_generic_req(void
 	 * Perform the Hypervisor mapping in order to avoid XPU viloation
 	 * to the allocated region for Modem Clients
 	 */
-	if (!memblock[client_id].hyp_mapping &&
+	if (!memblock[client_id].hyp_mapping && !resp &&
 		memblock[client_id].alloted)
 		shared_hyp_mapping(client_id);
 	mutex_unlock(&memsh_drv->mem_share);
-	pr_debug("memshare: alloc_resp.num_bytes :%d, alloc_resp.handle :%lx, alloc_resp.mem_req_result :%lx\n",
+	pr_info("memshare: alloc_resp: num_bytes :0x%x, phy_addr :%lx, resp.result :%lx\n",
 			  alloc_resp->dhms_mem_alloc_addr_info[0].num_bytes,
 			  (unsigned long int)
 			  alloc_resp->dhms_mem_alloc_addr_info[0].phy_addr,
@@ -558,6 +856,11 @@ static int handle_free_req(void *req_h,
 			memblock[GPS].virtual_addr,
 				free_req->handle);
 	}
+#ifdef CONFIG_SEC_BSP
+	memshare_unset_nhlos_permission(memblock[GPS].phy_addr,
+			memsh_drv->memshare_rd_dev->size);
+	memsh_drv->memshare_rd_dev->data_ready = 0;
+#endif
 	free_resp.resp = QMI_RESULT_SUCCESS_V01;
 	mutex_unlock(&memsh_drv->mem_free);
 	rc = qmi_send_resp_from_cb(mem_share_svc_handle, conn_h, req_h,
@@ -617,6 +920,13 @@ static int handle_free_generic_req(void
 		free_resp.resp.error = QMI_ERR_NONE_V01;
 	}
 
+#ifdef CONFIG_SEC_BSP
+	memshare_unset_nhlos_permission(memblock[client_id].phy_addr,
+			memsh_drv->memshare_rd_dev->size);
+	memblock[client_id].hyp_mapping = 0;
+	memsh_drv->memshare_rd_dev->data_ready = 0;
+#endif
+
 	mutex_unlock(&memsh_drv->mem_free);
 	rc = qmi_send_resp_from_cb(mem_share_svc_handle, conn_h, req_h,
 		&mem_share_svc_free_generic_resp_desc, &free_resp,
@@ -668,7 +978,7 @@ static int handle_query_size_req(void *r
 	query_resp->resp.error = QMI_ERR_NONE_V01;
 	mutex_unlock(&memsh_drv->mem_share);
 
-	pr_debug("memshare: query_resp.size :%d, alloc_resp.mem_req_result :%lx\n",
+	pr_debug("memshare: query_resp->size :%d, query_resp->resp.result :%lx\n",
 			  query_resp->size,
 			  (unsigned long int)query_resp->resp.result);
 	rc = qmi_send_resp_from_cb(mem_share_svc_handle, conn_h, req_h,
@@ -823,7 +1133,7 @@ int memshare_alloc(struct device *dev,
 
 	int ret;
 
-	pr_debug("%s: memshare_alloc called", __func__);
+	pr_debug("%s: memshare_alloc called\n", __func__);
 	if (!pblk) {
 		pr_err("%s: Failed to alloc\n", __func__);
 		return -ENOMEM;
@@ -837,8 +1147,8 @@ int memshare_alloc(struct device *dev,
 		ret = -ENOMEM;
 		return ret;
 	}
-	pr_debug("pblk->phy_addr :%lx, pblk->virtual_addr %lx\n",
-		  (unsigned long int)pblk->phy_addr,
+	pr_info("%s: pblk->phy_addr : 0x%lx, pblk->virtual_addr : 0x%lx\n",
+			__func__, (unsigned long int)pblk->phy_addr,
 		  (unsigned long int)pblk->virtual_addr);
 	return 0;
 }
@@ -930,7 +1240,7 @@ static int memshare_child_probe(struct p
   /*
    *	Memshare allocation for guaranteed clients
    */
-	if (memblock[num_clients].guarantee) {
+	if (memblock[num_clients].guarantee && size > 0) {
 		rc = memshare_alloc(memsh_child->dev,
 				memblock[num_clients].size,
 				&memblock[num_clients]);
@@ -940,6 +1250,7 @@ static int memshare_child_probe(struct p
 			return rc;
 		}
 		memblock[num_clients].alloted = 1;
+		shared_hyp_mapping(num_clients);
 	}
 
 	/*
@@ -947,6 +1258,8 @@ static int memshare_child_probe(struct p
 	 *  memshare clients
 	 */
 
+	memshare_dev[num_clients] = &pdev->dev;
+
 	if (!memblock[num_clients].file_created) {
 		rc = mem_share_configure_ramdump();
 		if (rc)
@@ -998,6 +1311,17 @@ static int memshare_probe(struct platfor
 	subsys_notif_register_notifier("modem", &nb);
 	pr_info("In %s, Memshare probe success\n", __func__);
 
+#ifdef CONFIG_SEC_BSP
+	drv->memshare_rd_dev = create_memshare_rd_device(MEMSHARE_DEV_NAME, 
+								&pdev->dev);
+	if (!drv->memshare_rd_dev) {
+		pr_err("%s : Unable to create a memshare ramdump device.\n",
+				__func__);
+		rc = -ENOMEM;
+		return rc;
+	}
+#endif
+
 	return 0;
 }
 
@@ -1011,6 +1335,9 @@ static int memshare_remove(struct platfo
 	qmi_handle_destroy(mem_share_svc_handle);
 	destroy_workqueue(mem_share_svc_workqueue);
 
+#ifdef CONFIG_SEC_BSP
+	destroy_memshare_rd_device(memsh_drv->memshare_rd_dev);
+#endif
 	return 0;
 }
 
