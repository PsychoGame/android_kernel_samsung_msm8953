--- original/drivers/md/dm-req-crypt.c	2020-05-07 11:02:09.584858060 +0200
+++ changed/drivers/md/dm-req-crypt.c	2019-06-03 13:39:50.000000000 +0200
@@ -35,6 +35,11 @@
 #include <crypto/algapi.h>
 #include <crypto/ice.h>
 
+#ifdef CONFIG_CRYPTO_FDE_KEY_UPDATE
+#include <soc/qcom/scm.h>
+#include <soc/qcom/qseecomi.h>
+#endif
+
 #define DM_MSG_PREFIX "req-crypt"
 
 #define MAX_SG_LIST	1024
@@ -74,6 +79,36 @@ struct req_crypt_result {
 #define FDE_KEY_ID	0
 #define PFE_KEY_ID	1
 
+#ifdef CONFIG_CRYPTO_FDE_KEY_UPDATE
+#define TZ_ES_SET_ICE_KEY 0x2
+#define TZ_ES_INVALIDATE_ICE_KEY 0x3
+
+/* index 0 and 1 is reserved for FDE */
+#define TZ_ES_SET_ICE_KEY_ID \
+	TZ_SYSCALL_CREATE_SMC_ID(TZ_OWNER_SIP, TZ_SVC_ES, TZ_ES_SET_ICE_KEY)
+
+#define TZ_ES_INVALIDATE_ICE_KEY_ID \
+	TZ_SYSCALL_CREATE_SMC_ID(TZ_OWNER_SIP, \
+		TZ_SVC_ES, TZ_ES_INVALIDATE_ICE_KEY)
+
+#define TZ_ES_SET_ICE_KEY_PARAM_ID \
+	TZ_SYSCALL_CREATE_PARAM_ID_6( \
+		TZ_SYSCALL_PARAM_TYPE_VAL, TZ_SYSCALL_PARAM_TYPE_BUF_RW, TZ_SYSCALL_PARAM_TYPE_VAL, \
+		TZ_SYSCALL_PARAM_TYPE_BUF_RW, TZ_SYSCALL_PARAM_TYPE_VAL, TZ_SYSCALL_PARAM_TYPE_VAL)
+
+#define TZ_ES_INVALIDATE_ICE_KEY_PARAM_ID \
+	TZ_SYSCALL_CREATE_PARAM_ID_2( \
+	TZ_SYSCALL_PARAM_TYPE_VAL, TZ_SYSCALL_PARAM_TYPE_VAL)
+
+#define ICE_KEY_SIZE 32
+#define ICE_SALT_SIZE 32
+
+#define ICE_DM_CRYPT_KEY_IDEX 2
+
+uint8_t reset_ice_key[ICE_KEY_SIZE];
+uint8_t reset_ice_salt[ICE_SALT_SIZE];
+#endif
+
 static struct dm_dev *dev;
 static struct kmem_cache *_req_crypt_io_pool;
 static struct kmem_cache *_req_dm_scatterlist_pool;
@@ -135,6 +170,95 @@ static void req_cryptd_split_req_queue
 static void req_crypt_split_io_complete
 		(struct req_crypt_result *res, int err);
 
+#ifdef CONFIG_CRYPTO_FDE_KEY_UPDATE
+static int req_crypt_decode_key(uint8_t *key, uint8_t *hex, unsigned int size)
+{
+	char buffer[3];
+	unsigned int i;
+
+	buffer[2] = '\0';
+
+	for (i = 0; i < size; i++) {
+		buffer[0] = *hex++;
+		buffer[1] = *hex++;
+
+		if (kstrtou8(buffer, 16, &key[i]))
+			return -EINVAL;
+	}
+
+	if (*hex != '\0') {
+		DMERR("%s: Error\n", __func__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int req_crypt_ice_set_key(uint32_t index, uint8_t *key, uint8_t *salt)
+{
+	struct scm_desc desc = {0};
+	int ret;
+	char *tzbuf_key = (char *)reset_ice_key;
+	char *tzbuf_salt = (char *)reset_ice_salt;
+
+	uint32_t smc_id = 0;
+	u32 tzbuflen_key = sizeof(reset_ice_key);
+	u32 tzbuflen_salt = sizeof(reset_ice_salt);
+
+	if (index != ICE_DM_CRYPT_KEY_IDEX)
+		return -EINVAL;
+
+	if (!key || !salt)
+		return -EINVAL;
+
+	if (!tzbuf_key || !tzbuf_salt)
+		return -ENOMEM;
+
+	memset(tzbuf_key, 0, tzbuflen_key);
+	memset(tzbuf_salt, 0, tzbuflen_salt);
+
+	if (req_crypt_decode_key((uint8_t*)reset_ice_key, key, ICE_KEY_SIZE) < 0) {
+		DMERR("%s: Error: reset_ice_key\n", __func__);
+		return -EINVAL;
+	}
+	if (req_crypt_decode_key((uint8_t*)reset_ice_salt, salt, ICE_SALT_SIZE) < 0) {
+		DMERR("%s: Error: reset_ice_salt\n", __func__);
+		return -EINVAL;
+	}
+
+	dmac_flush_range(tzbuf_key, tzbuf_key + tzbuflen_key);
+	dmac_flush_range(tzbuf_salt, tzbuf_salt + tzbuflen_salt);
+
+	smc_id = TZ_ES_SET_ICE_KEY_ID;
+	DMDEBUG("%s , smc_id = 0x%x\n", __func__, smc_id);
+
+	desc.arginfo = TZ_ES_SET_ICE_KEY_PARAM_ID;
+	desc.args[0] = index;
+	desc.args[1] = virt_to_phys(tzbuf_key);
+	desc.args[2] = tzbuflen_key;
+	desc.args[3] = virt_to_phys(tzbuf_salt);
+	desc.args[4] = tzbuflen_salt;
+#ifdef CONFIG_SCSI_UFSHCD
+	desc.args[5] = 10;
+#else
+	desc.args[5] = 20;
+#endif
+
+	ret = scm_call2(smc_id, &desc);
+	DMDEBUG("%s , ret = %d\n", __func__, ret);
+	if (ret) {
+		DMERR("%s: Error: 0x%x\n", __func__, ret);
+
+		smc_id = TZ_ES_INVALIDATE_ICE_KEY_ID;
+		desc.arginfo = TZ_ES_INVALIDATE_ICE_KEY_PARAM_ID;
+		desc.args[0] = index;
+		scm_call2(smc_id, &desc);
+	}
+
+	return ret;
+}
+#endif
+
 static  bool req_crypt_should_encrypt(struct req_dm_crypt_io *req)
 {
 	int ret = 0;
@@ -1286,6 +1410,38 @@ static int req_crypt_ctr(struct dm_targe
 		ice_settings->key_size = ICE_CRYPTO_KEY_SIZE_128;
 		ice_settings->algo_mode = ICE_CRYPTO_ALGO_MODE_AES_XTS;
 		ice_settings->key_mode = ICE_CRYPTO_USE_LUT_SW_KEY;
+#ifdef CONFIG_CRYPTO_FDE_KEY_UPDATE
+		if (argc >= 8 && argv[7] && !strcmp(argv[7], "update_key")) {
+			ice_settings->key_index = ICE_DM_CRYPT_KEY_IDEX;
+
+#ifdef CONFIG_SCSI_UFSHCD
+			DMINFO("%s: This is UFS!\n", __func__);
+			if (qcom_ice_setup_ice_hw("ufs", true))
+#else
+			DMINFO("%s: This is eMMC!\n", __func__);
+			if (qcom_ice_setup_ice_hw("sdcc", true))
+#endif
+			{
+				DMERR("%s: could not enable clocks\n", __func__);
+				err = DM_REQ_CRYPT_ERROR;
+				goto ctr_exit;
+			}
+
+			if (!req_crypt_ice_set_key(ice_settings->key_index, (uint8_t*)argv[1], (uint8_t*)argv[8])) {
+				DMINFO("%s: New ICE key set success!\n", __func__);
+			} else {
+				DMERR("%s Err: New ICE key set fail\n", __func__);
+				err = DM_REQ_CRYPT_ERROR;
+				goto ctr_exit;
+			}
+
+#ifdef CONFIG_SCSI_UFSHCD
+			qcom_ice_setup_ice_hw("ufs", false);
+#else
+			qcom_ice_setup_ice_hw("sdcc", false);
+#endif
+		} else
+#endif
 		if (kstrtou16(argv[1], 0, &ice_settings->key_index) ||
 			ice_settings->key_index < 0 ||
 			ice_settings->key_index > MAX_MSM_ICE_KEY_LUT_SIZE) {
@@ -1294,6 +1450,9 @@ static int req_crypt_ctr(struct dm_targe
 			err = DM_REQ_CRYPT_ERROR;
 			goto ctr_exit;
 		}
+#ifdef CONFIG_CRYPTO_FDE_KEY_UPDATE
+		DMINFO("%s: Apply ICE key index : %d\n", __func__, ice_settings->key_index);
+#endif
 	} else {
 		ret = configure_qcrypto();
 		if (ret) {
@@ -1321,6 +1480,10 @@ static int req_crypt_ctr(struct dm_targe
 	DMINFO("%s: Mapping block_device %s to dm-req-crypt ok!\n",
 	       __func__, argv[3]);
 ctr_exit:
+#ifdef CONFIG_CRYPTO_FDE_KEY_UPDATE
+	memset(reset_ice_key, 0, ICE_SALT_SIZE);
+	memset(reset_ice_salt, 0, ICE_SALT_SIZE);
+#endif
 	if (err)
 		req_crypt_dtr(ti);
 
