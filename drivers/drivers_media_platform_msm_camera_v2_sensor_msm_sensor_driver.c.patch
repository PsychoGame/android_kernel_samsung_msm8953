--- original/drivers/media/platform/msm/camera_v2/sensor/msm_sensor_driver.c	2020-05-07 08:31:23.700806006 +0200
+++ changed/drivers/media/platform/msm/camera_v2/sensor/msm_sensor_driver.c	2019-06-03 13:39:50.000000000 +0200
@@ -9,21 +9,37 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  */
-
-#define SENSOR_DRIVER_I2C "camera"
+#define SENSOR_DRIVER_I2C "i2c_camera"
 /* Header file declaration */
 #include "msm_sensor.h"
 #include "msm_sd.h"
 #include "camera.h"
 #include "msm_cci.h"
 #include "msm_camera_dt_util.h"
+#include "msm_sensor_init.h"
 
 /* Logging macro */
 #undef CDBG
-#define CDBG(fmt, args...) pr_debug(fmt, ##args)
+#define CDBG(fmt, args...) pr_err(fmt, ##args)
 
 #define SENSOR_MAX_MOUNTANGLE (360)
 
+#if defined (CONFIG_CAMERA_SYSFS_V2)
+extern char rear_cam_info[CAMERA_INFO_MAXSIZE];		//camera_info
+extern char front_cam_info[CAMERA_INFO_MAXSIZE];	//camera_info
+#if defined(CONFIG_SAMSUNG_MULTI_CAMERA)
+#if defined(CONFIG_CAMERA_DUAL_REAR)
+extern char rear2_cam_info[CAMERA_INFO_MAXSIZE];	//camera_info
+#endif
+#if defined(CONFIG_CAMERA_DUAL_FRONT)
+extern char front2_cam_info[CAMERA_INFO_MAXSIZE];	//camera_info
+#endif
+#endif
+#if defined(CONFIG_SAMSUNG_SECURE_CAMERA)
+extern char iris_cam_info[CAMERA_INFO_MAXSIZE];	//camera_info
+#endif
+#endif
+
 static struct v4l2_file_operations msm_sensor_v4l2_subdev_fops;
 static int32_t msm_sensor_driver_platform_probe(struct platform_device *pdev);
 
@@ -108,11 +124,7 @@ static int32_t msm_sensor_driver_create_
 	s_ctrl->msm_sd.sd.entity.name =	s_ctrl->msm_sd.sd.name;
 	s_ctrl->sensordata->sensor_info->session_id = session_id;
 	s_ctrl->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x3;
-	rc = msm_sd_register(&s_ctrl->msm_sd);
-	if (rc < 0) {
-		pr_err("failed: msm_sd_register rc %d", rc);
-		return rc;
-	}
+	msm_sd_register(&s_ctrl->msm_sd);
 	msm_sensor_v4l2_subdev_fops = v4l2_subdev_fops;
 #ifdef CONFIG_COMPAT
 	msm_sensor_v4l2_subdev_fops.compat_ioctl32 =
@@ -152,11 +164,7 @@ static int32_t msm_sensor_driver_create_
 	s_ctrl->msm_sd.sd.entity.group_id = MSM_CAMERA_SUBDEV_SENSOR;
 	s_ctrl->msm_sd.sd.entity.name = s_ctrl->msm_sd.sd.name;
 	s_ctrl->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x3;
-	rc = msm_sd_register(&s_ctrl->msm_sd);
-	if (rc < 0) {
-		pr_err("failed: msm_sd_register rc %d", rc);
-		return rc;
-	}
+	msm_sd_register(&s_ctrl->msm_sd);
 	msm_cam_copy_v4l2_subdev_fops(&msm_sensor_v4l2_subdev_fops);
 #ifdef CONFIG_COMPAT
 	msm_sensor_v4l2_subdev_fops.compat_ioctl32 =
@@ -183,6 +191,7 @@ static int32_t msm_sensor_fill_eeprom_su
 
 	if (!s_ctrl->sensordata->eeprom_name || !of_node)
 		return -EINVAL;
+	CDBG("%s:%d JSH Eeprom name is %s\n", __func__, __LINE__, s_ctrl->sensordata->eeprom_name);
 
 	eeprom_name_len = strlen(s_ctrl->sensordata->eeprom_name);
 	if (eeprom_name_len >= MAX_SENSOR_NAME)
@@ -274,6 +283,7 @@ static int32_t msm_sensor_fill_actuator_
 	 * and try to found new id
 	 */
 	*actuator_subdev_id = -1;
+	CDBG("%s:%d JSH actuator name : %s\n", __func__, __LINE__, s_ctrl->sensordata->actuator_name);
 
 	if (0 == actuator_name_len)
 		return 0;
@@ -297,86 +307,93 @@ static int32_t msm_sensor_fill_actuator_
 	return rc;
 }
 
-static int32_t msm_sensor_fill_ois_subdevid_by_name(
+static int32_t msm_sensor_fill_flash_subdevid_by_name(
 				struct msm_sensor_ctrl_t *s_ctrl)
 {
 	int32_t rc = 0;
 	struct device_node *src_node = NULL;
-	uint32_t val = 0, ois_name_len;
-	int32_t *ois_subdev_id;
+	uint32_t val = 0, flash_name_len;
+	int32_t *flash_subdev_id;
 	struct  msm_sensor_info_t *sensor_info;
 	struct device_node *of_node = s_ctrl->of_node;
 
-	if (!s_ctrl->sensordata->ois_name || !of_node)
-		return -EINVAL;
-
-	ois_name_len = strlen(s_ctrl->sensordata->ois_name);
-	if (ois_name_len >= MAX_SENSOR_NAME)
+	if (!of_node || !s_ctrl->sensordata->flash_name)
 		return -EINVAL;
 
 	sensor_info = s_ctrl->sensordata->sensor_info;
-	ois_subdev_id = &sensor_info->subdev_id[SUB_MODULE_OIS];
-	/*
-	 * string for ois name is valid, set sudev id to -1
-	 * and try to found new id
-	 */
-	*ois_subdev_id = -1;
+	flash_subdev_id = &sensor_info->subdev_id[SUB_MODULE_LED_FLASH];
 
-	if (0 == ois_name_len)
+	*flash_subdev_id = -1;
+
+	flash_name_len = strlen(s_ctrl->sensordata->flash_name);
+	if (flash_name_len >= MAX_SENSOR_NAME)
+		return -EINVAL;
+
+	if (flash_name_len == 0)
 		return 0;
 
-	src_node = of_parse_phandle(of_node, "qcom,ois-src", 0);
+	src_node = of_parse_phandle(of_node, "qcom,led-flash-src", 0);
 	if (!src_node) {
 		CDBG("%s:%d src_node NULL\n", __func__, __LINE__);
 	} else {
 		rc = of_property_read_u32(src_node, "cell-index", &val);
-		CDBG("%s qcom,ois cell index %d, rc %d\n", __func__,
+		CDBG("%s qcom,flash cell index %d, rc %d\n", __func__,
 			val, rc);
 		if (rc < 0) {
 			pr_err("%s failed %d\n", __func__, __LINE__);
 			return -EINVAL;
 		}
-		*ois_subdev_id = val;
+		*flash_subdev_id = val;
 		of_node_put(src_node);
 		src_node = NULL;
 	}
-
 	return rc;
 }
 
-static int32_t msm_sensor_fill_flash_subdevid_by_name(
+static int32_t msm_sensor_fill_ois_subdevid_by_name(
 				struct msm_sensor_ctrl_t *s_ctrl)
 {
 	int32_t rc = 0;
 	struct device_node *src_node = NULL;
-	uint32_t val = 0;
-	int32_t *flash_subdev_id;
+	uint32_t val = 0, ois_name_len;
+	int32_t *ois_subdev_id;
 	struct  msm_sensor_info_t *sensor_info;
 	struct device_node *of_node = s_ctrl->of_node;
 
-	if (!of_node)
+	if (!s_ctrl->sensordata->ois_name || !of_node)
+		return -EINVAL;
+
+	ois_name_len = strlen(s_ctrl->sensordata->ois_name);
+	if (ois_name_len >= MAX_SENSOR_NAME)
 		return -EINVAL;
 
 	sensor_info = s_ctrl->sensordata->sensor_info;
-	flash_subdev_id = &sensor_info->subdev_id[SUB_MODULE_LED_FLASH];
+	ois_subdev_id = &sensor_info->subdev_id[SUB_MODULE_OIS];
+	/*
+	 * string for ois name is valid, set sudev id to -1
+	 * and try to found new id
+	 */
+	*ois_subdev_id = -1;
 
-	*flash_subdev_id = -1;
+	if (0 == ois_name_len)
+		return 0;
 
-	src_node = of_parse_phandle(of_node, "qcom,led-flash-src", 0);
+	src_node = of_parse_phandle(of_node, "qcom,ois-src", 0);
 	if (!src_node) {
 		CDBG("%s:%d src_node NULL\n", __func__, __LINE__);
 	} else {
 		rc = of_property_read_u32(src_node, "cell-index", &val);
-		CDBG("%s qcom,flash cell index %d, rc %d\n", __func__,
+		CDBG("%s qcom,ois cell index %d, rc %d\n", __func__,
 			val, rc);
 		if (rc < 0) {
 			pr_err("%s failed %d\n", __func__, __LINE__);
 			return -EINVAL;
 		}
-		*flash_subdev_id = val;
+		*ois_subdev_id = val;
 		of_node_put(src_node);
 		src_node = NULL;
 	}
+
 	return rc;
 }
 
@@ -678,6 +695,24 @@ static void msm_sensor_fill_sensor_info(
 }
 
 /* static function definition */
+static int32_t msm_sensor_driver_is_special_support(
+	struct msm_sensor_ctrl_t *s_ctrl,
+	char *sensor_name)
+{
+	int32_t rc = 0, i = 0;
+	struct msm_camera_sensor_board_info *sensordata = s_ctrl->sensordata;
+
+	for (i = 0; i < sensordata->special_support_size; i++) {
+		if (!strcmp(sensordata->special_support_sensors[i],
+						 sensor_name)) {
+			rc = TRUE;
+			break;
+		}
+	}
+	return rc;
+}
+
+/* static function definition */
 int32_t msm_sensor_driver_probe(void *setting,
 	struct msm_sensor_info_t *probed_info, char *entity_name)
 {
@@ -796,11 +831,11 @@ int32_t msm_sensor_driver_probe(void *se
 	CDBG("power up size %d power down size %d\n",
 		slave_info->power_setting_array.size,
 		slave_info->power_setting_array.size_down);
-	CDBG("position %d",
+	CDBG("position %d\n",
 		slave_info->sensor_init_params.position);
-	CDBG("mount %d",
+	CDBG("mount %d\n",
 		slave_info->sensor_init_params.sensor_mount_angle);
-	CDBG("bypass video node creation %d",
+	CDBG("bypass video node creation %d\n",
 		slave_info->bypass_video_node_creation);
 	/* Validate camera id */
 	if (slave_info->camera_id >= MAX_CAMERAS) {
@@ -821,6 +856,16 @@ int32_t msm_sensor_driver_probe(void *se
 
 	CDBG("s_ctrl[%d] %pK", slave_info->camera_id, s_ctrl);
 
+	if (s_ctrl->sensordata->special_support_size > 0) {
+		if (!msm_sensor_driver_is_special_support(s_ctrl,
+			slave_info->sensor_name)) {
+			pr_err("%s:%s is not support on this board\n",
+				__func__, slave_info->sensor_name);
+			rc = 0;
+			goto free_slave_info;
+		}
+	}
+
 	if (s_ctrl->is_probe_succeed == 1) {
 		/*
 		 * Different sensor on this camera slot has been connected
@@ -898,28 +943,30 @@ int32_t msm_sensor_driver_probe(void *se
 	cci_client->id_map = 0;
 	cci_client->i2c_freq_mode = slave_info->i2c_freq_mode;
 
-	/* Parse and fill vreg params for powerup settings */
-	rc = msm_camera_fill_vreg_params(
-		s_ctrl->sensordata->power_info.cam_vreg,
-		s_ctrl->sensordata->power_info.num_vreg,
-		s_ctrl->sensordata->power_info.power_setting,
-		s_ctrl->sensordata->power_info.power_setting_size);
-	if (rc < 0) {
-		pr_err("failed: msm_camera_get_dt_power_setting_data rc %d",
-			rc);
-		goto free_camera_info;
-	}
+	if (s_ctrl->sensordata->power_info.num_vreg > 0) {
+		/* Parse and fill vreg params for powerup settings */
+		rc = msm_camera_fill_vreg_params(
+			s_ctrl->sensordata->power_info.cam_vreg,
+			s_ctrl->sensordata->power_info.num_vreg,
+			s_ctrl->sensordata->power_info.power_setting,
+			s_ctrl->sensordata->power_info.power_setting_size);
+		if (rc < 0) {
+			pr_err("failed: msm_camera_get_dt_power_setting_data rc %d",
+				rc);
+			goto free_camera_info;
+		}
 
-	/* Parse and fill vreg params for powerdown settings*/
-	rc = msm_camera_fill_vreg_params(
-		s_ctrl->sensordata->power_info.cam_vreg,
-		s_ctrl->sensordata->power_info.num_vreg,
-		s_ctrl->sensordata->power_info.power_down_setting,
-		s_ctrl->sensordata->power_info.power_down_setting_size);
-	if (rc < 0) {
-		pr_err("failed: msm_camera_fill_vreg_params for PDOWN rc %d",
-			rc);
-		goto free_camera_info;
+		/* Parse and fill vreg params for powerdown settings*/
+		rc = msm_camera_fill_vreg_params(
+			s_ctrl->sensordata->power_info.cam_vreg,
+			s_ctrl->sensordata->power_info.num_vreg,
+			s_ctrl->sensordata->power_info.power_down_setting,
+			s_ctrl->sensordata->power_info.power_down_setting_size);
+		if (rc < 0) {
+			pr_err("failed: msm_camera_fill_vreg_params for PDOWN rc %d",
+				rc);
+			goto free_camera_info;
+		}
 	}
 
 CSID_TG:
@@ -968,6 +1015,12 @@ CSID_TG:
 
 	pr_err("%s probe succeeded", slave_info->sensor_name);
 
+	/*
+	  Set probe succeeded flag to 1 so that no other camera shall
+	 * probed on this slot
+	 */
+	s_ctrl->is_probe_succeed = 1;
+
 	s_ctrl->bypass_video_node_creation =
 		slave_info->bypass_video_node_creation;
 
@@ -1023,11 +1076,6 @@ CSID_TG:
 
 	msm_sensor_fill_sensor_info(s_ctrl, probed_info, entity_name);
 
-	/*
-	 * Set probe succeeded flag to 1 so that no other camera shall
-	 * probed on this slot
-	 */
-	s_ctrl->is_probe_succeed = 1;
 	return rc;
 
 camera_power_down:
@@ -1041,7 +1089,7 @@ free_slave_info:
 
 static int32_t msm_sensor_driver_get_dt_data(struct msm_sensor_ctrl_t *s_ctrl)
 {
-	int32_t                              rc = 0;
+	int32_t                              rc = 0, i = 0;
 	struct msm_camera_sensor_board_info *sensordata = NULL;
 	struct device_node                  *of_node = s_ctrl->of_node;
 	uint32_t cell_id;
@@ -1079,6 +1127,35 @@ static int32_t msm_sensor_driver_get_dt_
 		goto FREE_SENSOR_DATA;
 	}
 
+	sensordata->special_support_size =
+		of_property_count_strings(of_node,
+				 "qcom,special-support-sensors");
+
+	if (sensordata->special_support_size < 0)
+		sensordata->special_support_size = 0;
+
+	if (sensordata->special_support_size > MAX_SPECIAL_SUPPORT_SIZE) {
+		pr_debug("%s:support_size exceed max support size\n", __func__);
+		sensordata->special_support_size = MAX_SPECIAL_SUPPORT_SIZE;
+	}
+
+	if (sensordata->special_support_size) {
+		for (i = 0; i < sensordata->special_support_size; i++) {
+			rc = of_property_read_string_index(of_node,
+				"qcom,special-support-sensors", i,
+				&(sensordata->special_support_sensors[i]));
+			if (rc < 0) {
+				/* if read sensor support names failed,
+				*   set support all sensors, break;
+				*/
+				sensordata->special_support_size = 0;
+				break;
+			}
+			CDBG("%s special_support_sensors[%d] = %s\n", __func__,
+				i, sensordata->special_support_sensors[i]);
+		}
+	}
+
 	/* Read subdev info */
 	rc = msm_sensor_get_sub_module_index(of_node, &sensordata->sensor_info);
 	if (rc < 0) {
@@ -1157,6 +1234,51 @@ static int32_t msm_sensor_driver_get_dt_
 	CDBG("%s qcom,mclk-23880000 = %d\n", __func__,
 		s_ctrl->set_mclk_23880000);
 
+#if defined (CONFIG_CAMERA_SYSFS_V2)
+	/* camera information */
+	if (cell_id == 0) {
+		rc = msm_camera_get_dt_camera_info(of_node, rear_cam_info);
+		if (rc < 0) {
+			pr_err("failed: msm_camera_get_dt_camera_info for rear rc %d", rc);
+			goto FREE_VREG_DATA;
+		}
+	} else if (cell_id == 1) {
+		rc = msm_camera_get_dt_camera_info(of_node, front_cam_info);
+		if (rc < 0) {
+			pr_err("failed: msm_camera_get_dt_camera_info for front rc %d", rc);
+			goto FREE_VREG_DATA;
+		}
+	}
+#if defined(CONFIG_SAMSUNG_MULTI_CAMERA)
+#if defined(CONFIG_CAMERA_DUAL_REAR)
+	else if (cell_id == 2) {
+		rc = msm_camera_get_dt_camera_info(of_node, rear2_cam_info);
+		if (rc < 0) {
+			pr_err("failed: msm_camera_get_dt_camera_info for rear2 rc %d", rc);
+			goto FREE_VREG_DATA;
+		}
+	}
+#endif
+#if defined(CONFIG_CAMERA_DUAL_FRONT)
+	else if (cell_id == 2) {
+		rc = msm_camera_get_dt_camera_info(of_node, front2_cam_info);
+		if (rc < 0) {
+			pr_err("failed: msm_camera_get_dt_camera_info for front2 rc %d", rc);
+			goto FREE_VREG_DATA;
+		}
+	}
+#endif
+#endif
+#if defined(CONFIG_SAMSUNG_SECURE_CAMERA)
+	else if (cell_id == 4) {
+		rc = msm_camera_get_dt_camera_info(of_node, iris_cam_info);
+		if (rc < 0) {
+			pr_err("failed: msm_camera_get_dt_camera_info for iris rc %d", rc);
+			goto FREE_VREG_DATA;
+		}
+	}
+#endif
+#endif
 	return rc;
 
 FREE_VREG_DATA:
@@ -1362,12 +1484,12 @@ static const struct i2c_device_id i2c_id
 };
 
 static struct i2c_driver msm_sensor_driver_i2c = {
-	.id_table = i2c_id,
-	.probe  = msm_sensor_driver_i2c_probe,
-	.remove = msm_sensor_driver_i2c_remove,
-	.driver = {
-		.name = SENSOR_DRIVER_I2C,
-	},
+    .id_table = i2c_id,
+    .probe  = msm_sensor_driver_i2c_probe,
+    .remove = msm_sensor_driver_i2c_remove,
+    .driver = {
+        .name = SENSOR_DRIVER_I2C,
+    },
 };
 
 static int __init msm_sensor_driver_init(void)
