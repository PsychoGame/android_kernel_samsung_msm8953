--- original/drivers/usb/gadget/function/f_midi.c	2020-05-07 08:53:30.891121211 +0200
+++ changed/drivers/usb/gadget/function/f_midi.c	2019-06-03 13:39:52.000000000 +0200
@@ -45,7 +45,7 @@ static const char f_midi_longname[] = "M
  * stored in 4-bit fields. And as the interface currently only holds one
  * single endpoint, this is the maximum number of ports we can allow.
  */
-#define MAX_PORTS 16
+#define MAX_PORTS 1
 
 /*
  * This is a gadget, and the IN/OUT naming is from the host's perspective.
@@ -92,7 +92,7 @@ struct f_midi {
 	unsigned int buflen, qlen;
 };
 
-static struct f_midi *the_midi;
+static struct f_midi *_midi;
 
 static inline struct f_midi *func_to_midi(struct usb_function *f)
 {
@@ -409,16 +409,10 @@ static void f_midi_unbind(struct usb_con
 	f_midi_disable(f);
 
 	card = midi->card;
-	midi->card = NULL;
 	if (card)
 		snd_card_free_when_closed(card);
 
-	kfree(midi->id);
-	midi->id = NULL;
-
 	usb_free_all_descriptors(f);
-	kfree(midi);
-	the_midi = NULL;
 }
 
 static int f_midi_snd_free(struct snd_device *device)
@@ -592,10 +586,6 @@ static int f_midi_in_open(struct snd_raw
 {
 	struct f_midi *midi = substream->rmidi->private_data;
 
-	/* check if midi got disabled or re-enabled quickly */
-	if (midi != the_midi)
-		return -ENODEV;
-
 	if (!midi->in_port[substream->number])
 		return -EINVAL;
 
@@ -617,10 +607,6 @@ static void f_midi_in_trigger(struct snd
 {
 	struct f_midi *midi = substream->rmidi->private_data;
 
-	/* check if midi got disabled or re-enabled quickly */
-	if (midi != the_midi)
-		return;
-
 	if (!midi->in_port[substream->number])
 		return;
 
@@ -634,10 +620,6 @@ static int f_midi_out_open(struct snd_ra
 {
 	struct f_midi *midi = substream->rmidi->private_data;
 
-	/* check if midi got disabled or re-enabled quickly */
-	if (midi != the_midi)
-		return -ENODEV;
-
 	if (substream->number >= MAX_PORTS)
 		return -EINVAL;
 
@@ -658,10 +640,6 @@ static void f_midi_out_trigger(struct sn
 {
 	struct f_midi *midi = substream->rmidi->private_data;
 
-	/* check if midi got disabled or re-enabled quickly */
-	if (midi != the_midi)
-		return;
-
 	VDBG(midi, "%s()\n", __func__);
 
 	if (up)
@@ -939,8 +917,8 @@ f_midi_bind(struct usb_configuration *c,
 		goto fail_f_midi;
 
 	if (gadget_is_dualspeed(c->cdev->gadget)) {
-		bulk_in_desc.wMaxPacketSize = cpu_to_le16(512);
-		bulk_out_desc.wMaxPacketSize = cpu_to_le16(512);
+		bulk_in_desc.wMaxPacketSize = cpu_to_le16(midi->buflen);
+		bulk_out_desc.wMaxPacketSize = cpu_to_le16(midi->buflen);
 		f->hs_descriptors = usb_copy_descriptors(midi_function);
 		if (!f->hs_descriptors)
 			goto fail_f_midi;
@@ -1006,24 +984,12 @@ int /* __init */ f_midi_bind_config(stru
 	if (in_ports > MAX_PORTS || out_ports > MAX_PORTS)
 		return -EINVAL;
 
-	/* allocate and initialize one new instance */
-	midi = kzalloc(sizeof *midi, GFP_KERNEL);
-	if (!midi) {
-		status = -ENOMEM;
-		goto fail;
-	}
+	midi = _midi;
 
 	for (i = 0; i < in_ports; i++) {
-		struct gmidi_in_port *port = kzalloc(sizeof(*port), GFP_KERNEL);
-		if (!port) {
-			status = -ENOMEM;
-			goto setup_fail;
-		}
-
-		port->midi = midi;
-		port->active = 0;
-		port->cable = i;
-		midi->in_port[i] = port;
+		midi->in_port[i]->active = 0;
+		midi->in_port[i]->cable = i;
+		midi->in_port[i]->state = STATE_UNKNOWN;
 	}
 
 	midi->gadget = c->cdev->gadget;
@@ -1051,7 +1017,6 @@ int /* __init */ f_midi_bind_config(stru
 	if (status)
 		goto setup_fail;
 
-	the_midi = midi;
 
 	if (config) {
 		config->card = midi->rmidi->card->number;
@@ -1061,10 +1026,45 @@ int /* __init */ f_midi_bind_config(stru
 	return 0;
 
 setup_fail:
+	return status;
+}
+
+static int f_midi_setup(void)
+{
+	struct f_midi *midi;
+	int i, status;
+
+	/* allocate and initialize one new instance */
+	midi = kzalloc(sizeof *midi, GFP_KERNEL);
+	if (!midi) {
+		return -ENOMEM;
+	}
+	_midi = midi;
+
+	for (i = 0; i < MAX_PORTS; i++) {
+		struct gmidi_in_port *port = kzalloc(sizeof(*port), GFP_KERNEL);
+		if (!port) {
+			status = -ENOMEM;
+			goto setup_fail;
+		}
+		port->midi = midi;
+		midi->in_port[i] = port;
+	}
+	return 0;
+
+setup_fail:
 	for (--i; i >= 0; i--)
 		kfree(midi->in_port[i]);
+
 	kfree(midi);
-fail:
 	return status;
 }
 
+static void f_midi_cleanup(void)
+{
+	int i;
+	for (i = 0; i < MAX_PORTS; i++)
+		kfree(_midi->in_port[i]);
+	kfree(_midi);
+}
+
