--- original/drivers/soc/qcom/watchdog_v2.c	2020-05-07 08:06:17.691228388 +0200
+++ changed/drivers/soc/qcom/watchdog_v2.c	2019-06-03 13:39:52.000000000 +0200
@@ -30,6 +30,10 @@
 #include <soc/qcom/memory_dump.h>
 #include <soc/qcom/watchdog.h>
 
+#include <linux/sec_bsp.h>
+#include <linux/sec_debug.h>
+#include <linux/sec_debug_summary.h>
+
 #define MODULE_NAME "msm_watchdog"
 #define WDT0_ACCSCSSNBARK_INT 0
 #define TCSR_WDT_CFG	0x30
@@ -87,6 +91,10 @@ struct msm_watchdog_data {
  */
 static int enable = 1;
 module_param(enable, int, 0);
+#ifdef CONFIG_SEC_DEBUG
+static void __iomem * wdog_base_addr;
+extern void sec_debug_save_last_pet(unsigned long long last_pet);
+#endif
 
 /*
  * On the kernel command line specify
@@ -254,6 +262,21 @@ static ssize_t wdog_disable_set(struct d
 static DEVICE_ATTR(disable, S_IWUSR | S_IRUSR, wdog_disable_get,
 							wdog_disable_set);
 
+#ifdef CONFIG_SEC_DEBUG
+static unsigned long long last_emerg_pet;
+
+void emerg_pet_watchdog(void)
+{
+	if (wdog_base_addr && enable) {
+		__raw_writel(1, wdog_base_addr + WDT0_EN);
+		__raw_writel(1, wdog_base_addr + WDT0_RST);
+
+		mb();
+		last_emerg_pet = sched_clock();
+	}
+}
+#endif
+
 static void pet_watchdog(struct msm_watchdog_data *wdog_dd)
 {
 	int slack, i, count, prev_count = 0;
@@ -277,6 +300,13 @@ static void pet_watchdog(struct msm_watc
 	if (slack_ns < wdog_dd->min_slack_ns)
 		wdog_dd->min_slack_ns = slack_ns;
 	wdog_dd->last_pet = time_ns;
+
+#ifdef CONFIG_SEC_DEBUG
+	sec_debug_save_last_pet(time_ns);
+#endif
+#ifdef CONFIG_SEC_DEBUG_PWDT
+	sec_debug_check_pwdt();
+#endif
 }
 
 static void keep_alive_response(void *info)
@@ -411,6 +441,8 @@ static irqreturn_t wdog_bark_handler(int
 	printk(KERN_INFO "Watchdog bark! Now = %lu.%06lu\n", (unsigned long) t,
 		nanosec_rem / 1000);
 
+	sec_debug_prepare_for_wdog_bark_reset();
+
 	nanosec_rem = do_div(wdog_dd->last_pet, 1000000000);
 	printk(KERN_INFO "Watchdog last pet at %lu.%06lu\n", (unsigned long)
 		wdog_dd->last_pet, nanosec_rem / 1000);
@@ -494,9 +526,22 @@ static void configure_bark_dump(struct m
 			goto out1;
 		}
 
+		sec_debug_summary_bark_dump((unsigned long)cpu_data,
+				(unsigned long)virt_to_phys(cpu_data),
+				(unsigned long)cpu_buf,
+				(unsigned long)virt_to_phys(cpu_buf),
+				MAX_CPU_CTX_SIZE);
+
 		for_each_cpu(cpu, cpu_present_mask) {
 			cpu_data[cpu].addr = virt_to_phys(cpu_buf +
 							cpu * MAX_CPU_CTX_SIZE);
+
+#ifdef CONFIG_SEC_DEBUG
+			pr_info("WDOG_V2 handled by TZ: for cpu[%d] @0x%llx PA:0x%lx\n",
+				 cpu, cpu_data[cpu].addr,
+				(unsigned long)(cpu_buf + cpu * MAX_CPU_CTX_SIZE));
+#endif
+
 			cpu_data[cpu].len = MAX_CPU_CTX_SIZE;
 			dump_entry.id = MSM_DUMP_DATA_CPU_CTX + cpu;
 			dump_entry.addr = virt_to_phys(&cpu_data[cpu]);
@@ -585,6 +630,10 @@ static void init_watchdog_data(struct ms
 	__raw_writel(1, wdog_dd->base + WDT0_RST);
 	wdog_dd->last_pet = sched_clock();
 	wdog_dd->enabled = true;
+#ifdef CONFIG_SEC_DEBUG
+	sec_debug_save_last_pet(wdog_dd->last_pet);
+#endif
+
 	error = device_create_file(wdog_dd->dev, &dev_attr_disable);
 	if (error)
 		dev_err(wdog_dd->dev, "cannot create sysfs attribute\n");
@@ -610,6 +659,19 @@ static void dump_pdata(struct msm_watchd
 								pdata->base);
 }
 
+#ifdef CONFIG_USER_RESET_DEBUG_TEST
+void force_watchdog_bark(void)
+{
+	u64 timeout;
+
+	wdog_data->bark_time = 3000;
+	timeout = (wdog_data->bark_time * WDT_HZ) / 1000;
+	__raw_writel(timeout, wdog_data->base + WDT0_BARK_TIME);
+	pr_err("%s force set bark time [%d]\n", __func__, wdog_data->bark_time);
+}
+EXPORT_SYMBOL(force_watchdog_bark);
+#endif
+
 static int msm_wdog_dt_to_pdata(struct platform_device *pdev,
 					struct msm_watchdog_data *pdata)
 {
@@ -637,6 +699,10 @@ static int msm_wdog_dt_to_pdata(struct p
 		return -ENXIO;
 	}
 
+#ifdef CONFIG_SEC_DEBUG
+	wdog_base_addr = pdata->base;
+#endif
+
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
 					   "wdt-absent-base");
 	if (res) {
@@ -658,6 +724,14 @@ static int msm_wdog_dt_to_pdata(struct p
 		dev_err(&pdev->dev, "reading bark time failed\n");
 		return -ENXIO;
 	}
+
+	if (sec_bsp_is_console_enabled()) {
+		pdata->bark_time += 10000; // add 10 seconds
+		dev_info(&pdev->dev,
+			"console_enabled : wdog bark time added 10 sec.-> %d\n",
+			pdata->bark_time);
+	}
+
 	ret = of_property_read_u32(node, "qcom,pet-time", &pdata->pet_time);
 	if (ret) {
 		dev_err(&pdev->dev, "reading pet time failed\n");
