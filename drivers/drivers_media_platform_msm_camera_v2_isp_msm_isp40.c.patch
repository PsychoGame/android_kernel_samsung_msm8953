--- original/drivers/media/platform/msm/camera_v2/isp/msm_isp40.c	2020-05-07 08:31:23.653806428 +0200
+++ changed/drivers/media/platform/msm/camera_v2/isp/msm_isp40.c	2019-06-03 13:39:50.000000000 +0200
@@ -370,20 +370,18 @@ static void msm_vfe40_clear_status_reg(s
 static void msm_vfe40_process_reset_irq(struct vfe_device *vfe_dev,
 	uint32_t irq_status0, uint32_t irq_status1)
 {
-	unsigned long flags;
-
+        unsigned long flags;
 	if (irq_status0 & (1 << 31)) {
 		spin_lock_irqsave(&vfe_dev->reset_completion_lock, flags);
 		complete(&vfe_dev->reset_complete);
 		spin_unlock_irqrestore(&vfe_dev->reset_completion_lock, flags);
-	}
+        }
 }
 
 static void msm_vfe40_process_halt_irq(struct vfe_device *vfe_dev,
 	uint32_t irq_status0, uint32_t irq_status1)
-{
+{	
 	unsigned long flags;
-
 	if (irq_status1 & (1 << 8)) {
 		spin_lock_irqsave(&vfe_dev->halt_completion_lock, flags);
 		complete(&vfe_dev->halt_complete);
@@ -726,12 +724,6 @@ static void msm_vfe40_reg_update(struct
 		vfe_dev->reg_update_requested;
 	if ((vfe_dev->is_split && vfe_dev->pdev->id == ISP_VFE1) &&
 		((frame_src == VFE_PIX_0) || (frame_src == VFE_SRC_MAX))) {
-		if (!vfe_dev->common_data->dual_vfe_res->vfe_base[ISP_VFE0]) {
-			pr_err("%s vfe_base for ISP_VFE0 is NULL\n", __func__);
-			spin_unlock_irqrestore(&vfe_dev->reg_update_lock,
-				flags);
-			return;
-		}
 		msm_camera_io_w_mb(update_mask,
 			vfe_dev->common_data->dual_vfe_res->vfe_base[ISP_VFE0]
 			+ 0x378);
@@ -831,6 +823,10 @@ static void msm_vfe40_axi_enable_wm(void
 		val |= 0x1;
 	else
 		val &= ~0x1;
+	trace_printk("%s:%d  wm_idx %d enable %d\n",
+		__func__, __LINE__,
+		wm_idx,
+		enable);
 	msm_camera_io_w_mb(val,
 		vfe_base + VFE40_WM_BASE(wm_idx));
 }
@@ -1068,18 +1064,15 @@ static int msm_vfe40_start_fetch_engine(
 				fe_cfg->stream_id);
 		vfe_dev->fetch_engine_info.bufq_handle = bufq_handle;
 
-		mutex_lock(&vfe_dev->buf_mgr->lock);
 		rc = vfe_dev->buf_mgr->ops->get_buf_by_index(
 			vfe_dev->buf_mgr, bufq_handle, fe_cfg->buf_idx, &buf);
 		if (rc < 0 || !buf) {
 			pr_err("%s: No fetch buffer rc= %d\n",
 				__func__, rc);
-			mutex_unlock(&vfe_dev->buf_mgr->lock);
 			return -EINVAL;
 		}
 		mapped_info = buf->mapped_info[0];
 		buf->state = MSM_ISP_BUFFER_STATE_DISPATCHED;
-		mutex_unlock(&vfe_dev->buf_mgr->lock);
 	} else {
 		rc = vfe_dev->buf_mgr->ops->map_buf(vfe_dev->buf_mgr,
 			&mapped_info, fe_cfg->fd);
@@ -1131,15 +1124,14 @@ static int msm_vfe40_start_fetch_engine_
 		mutex_lock(&vfe_dev->buf_mgr->lock);
 		rc = vfe_dev->buf_mgr->ops->get_buf_by_index(
 			vfe_dev->buf_mgr, bufq_handle, fe_cfg->buf_idx, &buf);
+		mutex_unlock(&vfe_dev->buf_mgr->lock);
 		if (rc < 0 || !buf) {
 			pr_err("%s: No fetch buffer rc= %d buf= %pK\n",
 				__func__, rc, buf);
-			mutex_unlock(&vfe_dev->buf_mgr->lock);
 			return -EINVAL;
 		}
 		mapped_info = buf->mapped_info[0];
 		buf->state = MSM_ISP_BUFFER_STATE_DISPATCHED;
-		mutex_unlock(&vfe_dev->buf_mgr->lock);
 	} else {
 		rc = vfe_dev->buf_mgr->ops->map_buf(vfe_dev->buf_mgr,
 			&mapped_info, fe_cfg->fd);
@@ -1237,10 +1229,6 @@ static void msm_vfe40_cfg_fetch_engine(s
 	case V4L2_PIX_FMT_P16GBRG10:
 	case V4L2_PIX_FMT_P16GRBG10:
 	case V4L2_PIX_FMT_P16RGGB10:
-	case V4L2_PIX_FMT_P16BGGR12:
-	case V4L2_PIX_FMT_P16GBRG12:
-	case V4L2_PIX_FMT_P16GRBG12:
-	case V4L2_PIX_FMT_P16RGGB12:
 		main_unpack_pattern = 0xB210;
 		break;
 	default:
@@ -1535,7 +1523,6 @@ static void msm_vfe40_update_camif_state
 		msm_camera_io_w_mb((update_state == DISABLE_CAMIF ? 0x0 : 0x6),
 				vfe_dev->vfe_base + 0x2F4);
 		vfe_dev->axi_data.src_info[VFE_PIX_0].active = 0;
-		vfe_dev->axi_data.src_info[VFE_PIX_0].flag = 0;
 		/* testgen OFF*/
 		if (vfe_dev->axi_data.src_info[VFE_PIX_0].input_mux == TESTGEN)
 			msm_camera_io_w(1 << 1, vfe_dev->vfe_base + 0x93C);
@@ -1588,7 +1575,13 @@ static void msm_vfe40_axi_cfg_wm_reg(
 	} else {
 		burst_len = VFE40_BURST_LEN;
 	}
-
+     	trace_printk("%s:%d state %d src %d stream id %d session_id %x frame_base %d\n",
+		__func__, __LINE__,
+		stream_info->state,
+		stream_info->stream_src,
+		stream_info->stream_id,
+		stream_info->session_id,
+		stream_info->frame_based);
 	if (!stream_info->frame_based) {
 		msm_camera_io_w(0x0, vfe_dev->vfe_base + wm_base);
 		/*WR_IMAGE_SIZE*/
@@ -1749,7 +1742,9 @@ static int msm_vfe40_axi_halt(struct vfe
 	int rc = 0;
 	enum msm_vfe_input_src i;
 	unsigned long flags;
+    uint32_t irq_status1, vfe_halted = 0; 
 
+	CDBG("%s E\n", __func__); 
 	/* Keep only halt and restart mask */
 	msm_vfe40_set_halt_restart_mask(vfe_dev);
 
@@ -1762,6 +1757,7 @@ static int msm_vfe40_axi_halt(struct vfe
 		/* if any stream is waiting for update, signal complete */
 		if (vfe_dev->axi_data.stream_update[i]) {
 			ISP_DBG("%s: complete stream update\n", __func__);
+			trace_printk("%s: complete stream update vfe%d\n", __func__,vfe_dev->pdev->id);
 			msm_isp_axi_stream_update(vfe_dev, i);
 			if (vfe_dev->axi_data.stream_update[i])
 				msm_isp_axi_stream_update(vfe_dev, i);
@@ -1769,6 +1765,8 @@ static int msm_vfe40_axi_halt(struct vfe
 		if (atomic_read(&vfe_dev->axi_data.axi_cfg_update[i])) {
 			ISP_DBG("%s: complete on axi config update\n",
 				__func__);
+			trace_printk("%s: complete on axi config update vfe%d\n",
+				__func__,vfe_dev->pdev->id);
 			msm_isp_axi_cfg_update(vfe_dev, i);
 			if (atomic_read(&vfe_dev->axi_data.axi_cfg_update[i]))
 				msm_isp_axi_cfg_update(vfe_dev, i);
@@ -1782,10 +1780,14 @@ static int msm_vfe40_axi_halt(struct vfe
 			msm_isp_stats_stream_update(vfe_dev);
 	}
 
-	if (blocking) {
-		spin_lock_irqsave(&vfe_dev->halt_completion_lock, flags);
-		init_completion(&vfe_dev->halt_complete);
-		spin_unlock_irqrestore(&vfe_dev->halt_completion_lock, flags);
+    irq_status1 = msm_camera_io_r(vfe_dev->vfe_base + 0x3C); 
+    vfe_halted = irq_status1 & (1 << 8); 
+	 
+    if (blocking && (!vfe_halted)) { 
+	    spin_lock_irqsave(&vfe_dev->halt_completion_lock, flags);
+	    init_completion(&vfe_dev->halt_complete); 
+	    spin_unlock_irqrestore(&vfe_dev->halt_completion_lock, flags);
+
 		/* Halt AXI Bus Bridge */
 		msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x2C0);
 		rc = wait_for_completion_interruptible_timeout(
@@ -1797,7 +1799,8 @@ static int msm_vfe40_axi_halt(struct vfe
 		/* Halt AXI Bus Bridge */
 		msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x2C0);
 	}
-
+    CDBG("%s X\n", __func__); 
+	
 	return rc;
 }
 
