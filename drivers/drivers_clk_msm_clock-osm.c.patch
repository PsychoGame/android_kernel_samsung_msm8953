--- original/drivers/clk/msm/clock-osm.c	2020-05-07 08:06:09.697306938 +0200
+++ changed/drivers/clk/msm/clock-osm.c	2019-06-03 13:39:49.000000000 +0200
@@ -368,6 +368,52 @@ static int clk_osm_search_table(struct o
 	return -EINVAL;
 }
 
+#ifdef CONFIG_SEC_DEBUG_APPS_CLK_LOGGING
+typedef struct {
+	uint64_t ktime;
+	uint64_t qtime;
+	uint64_t rate;
+} apps_clk_log_t;
+
+#define MAX_CLK_LOG_CNT (10)
+
+typedef struct {
+	uint32_t max_cnt;
+	uint32_t index;
+	apps_clk_log_t log[MAX_CLK_LOG_CNT];
+} cpuclk_log_t;
+
+cpuclk_log_t cpuclk_log[2] = {
+	[0] = {.max_cnt = MAX_CLK_LOG_CNT,},
+	[1] = {.max_cnt = MAX_CLK_LOG_CNT,},
+};
+
+static void clk_osm_add_log(struct clk_osm *cpuclk, unsigned long rate)
+{
+	cpuclk_log_t *clk = NULL;
+	apps_clk_log_t *log = NULL;
+	uint64_t idx = 0;
+
+	if (!WARN(cpuclk->cluster_num < 0 || cpuclk->cluster_num >= 2,
+		"%s : invalid cluster_num(%u), dbg_name(%s)\n",
+		__func__, cpuclk->cluster_num, cpuclk->c.dbg_name)) {
+		clk = &cpuclk_log[cpuclk->cluster_num];
+		idx = clk->index;
+		log = &clk->log[idx];
+		log->ktime = local_clock();
+		log->qtime = arch_counter_get_cntvct();
+		log->rate = rate;
+		clk->index = (clk->index + 1) % MAX_CLK_LOG_CNT;
+	}
+}
+
+void* clk_osm_get_log_addr(void)
+{
+	return (void *)&cpuclk_log;
+}
+EXPORT_SYMBOL(clk_osm_get_log_addr);
+#endif /* CONFIG_SEC_DEBUG_APPS_CLK_LOGGING */
+
 static int clk_osm_set_rate(struct clk *c, unsigned long rate)
 {
 	struct clk_osm *cpuclk = to_clk_osm(c);
@@ -396,6 +442,9 @@ static int clk_osm_set_rate(struct clk *
 
 	/* Make sure the write goes through before proceeding */
 	mb();
+#ifdef CONFIG_SEC_DEBUG_APPS_CLK_LOGGING
+	clk_osm_add_log(cpuclk, rate);
+#endif /* CONFIG_SEC_DEBUG_APPS_CLK_LOGGING */
 
 	return 0;
 }
