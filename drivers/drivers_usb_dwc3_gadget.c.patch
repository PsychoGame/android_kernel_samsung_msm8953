--- original/drivers/usb/dwc3/gadget.c	2020-05-07 08:51:35.104255347 +0200
+++ changed/drivers/usb/dwc3/gadget.c	2019-06-03 13:39:52.000000000 +0200
@@ -30,6 +30,10 @@
 #include <linux/list.h>
 #include <linux/dma-mapping.h>
 
+#ifdef CONFIG_USB_NOTIFY_PROC_LOG
+#include <linux/usblog_proc_notify.h>
+#endif
+
 #include <linux/usb/ch9.h>
 #include <linux/usb/composite.h>
 #include <linux/usb/gadget.h>
@@ -294,9 +298,17 @@ void dwc3_gadget_giveback(struct dwc3_ep
 	trace_dwc3_gadget_giveback(req);
 
 	dbg_done(dep->number, req->request.actual, req->request.status);
+#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
+	if (req->request.complete) {
+		spin_unlock(&dwc->lock);
+		usb_gadget_giveback_request(&dep->endpoint, &req->request);
+		spin_lock(&dwc->lock);
+	}
+#else
 	spin_unlock(&dwc->lock);
 	usb_gadget_giveback_request(&dep->endpoint, &req->request);
 	spin_lock(&dwc->lock);
+#endif
 }
 
 int dwc3_send_gadget_generic_command(struct dwc3 *dwc, unsigned cmd, u32 param)
@@ -1153,8 +1165,13 @@ start_trb_queuing:
 			if (list_is_last(&req->list, &dep->request_list))
 				last_one = 1;
 
-			dwc3_prepare_one_trb(dep, req, dma, length,
-					last_one, false, 0, 0);
+                        if (usb_endpoint_dir_in(dep->endpoint.desc))
+	        		dwc3_prepare_one_trb(dep, req, dma, length,
+				        	last_one, false, 0, 0);
+                        else
+                                dwc3_prepare_one_trb(dep, req, dma, length,
+                                                1, false, 0, 0);
+
 
 			dbg_queue(dep->number, &req->request, 0);
 			if (last_one)
@@ -1925,6 +1942,9 @@ static int dwc3_gadget_run_stop(struct d
 	ktime_t start, diff;
 
 	reg = dwc3_readl(dwc->regs, DWC3_DCTL);
+
+	pr_info("usb: %s is_on:%d \n", __func__,is_on);
+
 	if (is_on) {
 		if (dwc->revision <= DWC3_REVISION_187A) {
 			reg &= ~DWC3_DCTL_TRGTULST_MASK;
@@ -2026,6 +2046,8 @@ static int dwc3_gadget_pullup(struct usb
 
 	is_on = !!is_on;
 
+	pr_info("usb: %s is_on: %d\n", __func__,is_on);
+
 	dwc->softconnect = is_on;
 
 	if ((dwc->is_drd && !dwc->vbus_active) || !dwc->gadget_driver) {
@@ -2104,6 +2126,8 @@ static int dwc3_gadget_vbus_session(stru
 	struct dwc3 *dwc = gadget_to_dwc(_gadget);
 	unsigned long flags;
 
+	pr_info("usb: %s is_active: %d \n", __func__,is_active);
+
 	if (!dwc->is_drd)
 		return -EPERM;
 
@@ -2111,6 +2135,14 @@ static int dwc3_gadget_vbus_session(stru
 
 	spin_lock_irqsave(&dwc->lock, flags);
 
+#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
+	if (dwc->vbus_active == is_active) {
+		printk(KERN_ERR "dwc3 state is same\n");
+		spin_unlock_irqrestore(&dwc->lock, flags);
+		return 0;
+	}
+#endif
+
 	/* Mark that the vbus was powered */
 	dwc->vbus_active = is_active;
 
@@ -2912,6 +2944,7 @@ static void dwc3_gadget_disconnect_inter
 {
 	int			reg;
 
+	pr_info("usb: %s\n", __func__);
 	dev_dbg(dwc->dev, "Notify OTG from %s\n", __func__);
 	dwc->b_suspend = false;
 	dwc3_notify_event(dwc, DWC3_CONTROLLER_NOTIFY_OTG_EVENT, 0);
@@ -2949,6 +2982,7 @@ void dwc3_gadget_usb3_phy_suspend(struct
 static void dwc3_gadget_reset_interrupt(struct dwc3 *dwc)
 {
 	u32			reg;
+	pr_info("usb: %s\n", __func__);
 
 	/*
 	 * WORKAROUND: DWC3 revisions <1.88a have an issue which
@@ -2980,7 +3014,10 @@ static void dwc3_gadget_reset_interrupt(
 		if (dwc->setup_packet_pending)
 			dwc3_gadget_disconnect_interrupt(dwc);
 	}
-
+#ifdef CONFIG_USB_CHARGING_EVENT
+	dwc->vbus_current= USB_CURRENT_UNCONFIGURED;
+	schedule_work(&dwc->set_vbus_current_work);
+#endif
 	dev_dbg(dwc->dev, "Notify OTG from %s\n", __func__);
 	dwc->b_suspend = false;
 	dwc3_notify_event(dwc, DWC3_CONTROLLER_NOTIFY_OTG_EVENT, 0);
@@ -3082,26 +3119,32 @@ static void dwc3_gadget_conndone_interru
 		dwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(512);
 		dwc->gadget.ep0->maxpacket = 512;
 		dwc->gadget.speed = USB_SPEED_SUPER;
+		pr_info("usb:: %s (SS)\n", __func__);
 		break;
 	case DWC3_DCFG_HIGHSPEED:
 		dwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(64);
 		dwc->gadget.ep0->maxpacket = 64;
 		dwc->gadget.l1_supported = false;
 		dwc->gadget.speed = USB_SPEED_HIGH;
+		pr_info("usb:: %s (HS)\n", __func__);
 		break;
 	case DWC3_DCFG_FULLSPEED2:
 	case DWC3_DCFG_FULLSPEED1:
 		dwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(64);
 		dwc->gadget.ep0->maxpacket = 64;
 		dwc->gadget.speed = USB_SPEED_FULL;
+		pr_info("usb:: %s (FS)\n", __func__);
 		break;
 	case DWC3_DCFG_LOWSPEED:
 		dwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(8);
 		dwc->gadget.ep0->maxpacket = 8;
 		dwc->gadget.speed = USB_SPEED_LOW;
+		pr_info("usb:: %s (LS)\n", __func__);
 		break;
 	}
 
+	dwc->eps[1]->endpoint.maxpacket = dwc->gadget.ep0->maxpacket;
+
 	/* Enable USB2 LPM Capability */
 
 	if ((dwc->revision > DWC3_REVISION_194A)
@@ -3172,7 +3215,7 @@ static void dwc3_gadget_wakeup_interrupt
 {
 	bool perform_resume = true;
 
-	dev_dbg(dwc->dev, "%s\n", __func__);
+	pr_info("usb: %s\n", __func__);
 
 	/*
 	 * Identify if it is called from wakeup_interrupt() context for bus
@@ -3358,7 +3401,10 @@ static void dwc3_gadget_suspend_interrup
 						__func__, dwc->gadget.state);
 			return;
 		}
-
+#ifdef CONFIG_USB_CHARGING_EVENT
+		dwc->vbus_current= USB_CURRENT_UNCONFIGURED;
+		schedule_work(&dwc->set_vbus_current_work);
+#endif
 		dwc3_suspend_gadget(dwc);
 
 		dev_dbg(dwc->dev, "Notify OTG from %s\n", __func__);
@@ -3404,6 +3450,10 @@ static void dwc3_gadget_interrupt(struct
 		break;
 	case DWC3_DEVICE_EVENT_RESET:
 		dwc3_gadget_reset_interrupt(dwc);
+#ifdef CONFIG_USB_NOTIFY_PROC_LOG
+		store_usblog_notify(NOTIFY_USBSTATE,
+					(void *)"USB_STATE=RESET", NULL);
+#endif
 		dwc->dbg_gadget_events.reset++;
 		break;
 	case DWC3_DEVICE_EVENT_CONNECT_DONE:
@@ -3466,7 +3516,7 @@ static void dwc3_gadget_interrupt(struct
 		dwc->dbg_gadget_events.overflow++;
 		break;
 	default:
-		dev_dbg(dwc->dev, "UNKNOWN IRQ %d\n", event->type);
+		pr_info("usb: [%s] UNKNOWN IRQ %d\n", __func__, event->type);
 		dwc->dbg_gadget_events.unknown_event++;
 	}
 
