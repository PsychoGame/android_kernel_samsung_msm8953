--- original/drivers/video/msm/mdss/mdss_mdp_intf_cmd.c	2020-05-07 08:51:35.121255180 +0200
+++ changed/drivers/video/msm/mdss/mdss_mdp_intf_cmd.c	2019-06-03 13:39:53.000000000 +0200
@@ -23,6 +23,10 @@
 #include "mdss_dsi_clk.h"
 #include <linux/interrupt.h>
 
+#if defined(CONFIG_FB_MSM_MDSS_SAMSUNG)
+#include "samsung/ss_dsi_panel_common.h"
+#endif
+
 #define MAX_RECOVERY_TRIALS 10
 #define MAX_SESSIONS 2
 
@@ -993,6 +997,10 @@ static void mdss_mdp_cmd_readptr_done(vo
 	MDSS_XLOG(ctl->num, atomic_read(&ctx->koff_cnt));
 	complete_all(&ctx->rdptr_done);
 
+#if defined(CONFIG_FB_MSM_MDSS_SAMSUNG)
+	LCD_DEBUG("ctl : %d koff_cnt : %d\n", ctl->num, atomic_read(&ctx->koff_cnt));
+#endif
+
 	/* If caller is waiting for the read pointer, notify. */
 	if (atomic_read(&ctx->rdptr_cnt)) {
 		if (atomic_add_unless(&ctx->rdptr_cnt, -1, 0)) {
@@ -1852,6 +1860,13 @@ int mdss_mdp_cmd_reconfigure_splash_done
 
 	clk_ctrl.state = MDSS_DSI_CLK_OFF;
 	clk_ctrl.client = DSI_CLK_REQ_MDP_CLIENT;
+
+	pr_err("%s ++ \n", __func__);
+
+#if defined(CONFIG_FB_MSM_MDSS_SAMSUNG)
+	/* Turning off mdp to re-initialize the mdp */
+	mdss_mdp_ctl_intf_event(ctl, MDSS_EVENT_BLANK, NULL, false);
+#endif
 	if (sctl) {
 		u32 flags = CTL_INTF_EVENT_FLAG_SKIP_BROADCAST;
 
@@ -1865,12 +1880,22 @@ int mdss_mdp_cmd_reconfigure_splash_done
 	mdss_mdp_ctl_intf_event(ctl, MDSS_EVENT_PANEL_CLK_CTRL,
 		(void *)&clk_ctrl, CTL_INTF_EVENT_FLAG_SKIP_BROADCAST);
 
+	pr_info("%s ++\n", __func__);
+
 	pdata->panel_info.cont_splash_enabled = 0;
+
+#if defined(CONFIG_FB_MSM_MDSS_SAMSUNG)
+	/* Turning off panel to initialize panel init-seq at kick-off*/
+	mdss_mdp_ctl_intf_event(ctl, MDSS_EVENT_PANEL_OFF, NULL, false);
+#endif
+
 	if (sctl)
 		sctl->panel_data->panel_info.cont_splash_enabled = 0;
 	else if (pdata->next && is_pingpong_split(ctl->mfd))
 		pdata->next->panel_info.cont_splash_enabled = 0;
 
+	pr_err("%s --\n", __func__);
+
 	return ret;
 }
 
@@ -1903,6 +1928,9 @@ static int mdss_mdp_cmd_wait4pingpong(st
 	struct mdss_panel_data *pdata;
 	unsigned long flags;
 	int rc = 0, te_irq;
+#if defined(CONFIG_FB_MSM_MDSS_SAMSUNG)
+	struct samsung_display_driver_data *vdd = samsung_get_vdd();
+#endif
 
 	ctx = (struct mdss_mdp_cmd_ctx *) ctl->intf_ctx[MASTER_CTX];
 	if (!ctx) {
@@ -1949,6 +1977,10 @@ static int mdss_mdp_cmd_wait4pingpong(st
 				__func__,
 				ctl->num, rc, ctx->pp_timeout_report_cnt,
 				atomic_read(&ctx->koff_cnt));
+#if defined(CONFIG_FB_MSM_MDSS_SAMSUNG)
+/*				SS_XLOG(ctx->pp_timeout_report_cnt);*/
+				inc_dpui_u32_field(DPUI_KEY_QCT_PPTO, 1);
+#endif
 
 		/* enable TE irq to check if it is coming from the panel */
 		te_irq = gpio_to_irq(pdata->panel_te_gpio);
@@ -1964,7 +1996,16 @@ static int mdss_mdp_cmd_wait4pingpong(st
 			MDSS_XLOG(0xbac);
 			mdss_fb_report_panel_dead(ctl->mfd);
 		} else if (ctx->pp_timeout_report_cnt == 0) {
-			MDSS_XLOG(0xbad);
+#if defined(CONFIG_FB_MSM_MDSS_SAMSUNG)
+			if (vdd->debug_data->panic_on_pptimeout) {
+				WARN(1, "cmd kickoff timed out (%d) ctl=%d\n", rc, ctl->num);
+				MDSS_XLOG(0xbad);
+				MDSS_XLOG_TOUT_HANDLER("mdp", "dsi0_ctrl", "dsi0_phy",
+						"dsi1_ctrl", "dsi1_phy", "vbif", "vbif_nrt",
+						"dbg_bus", "vbif_dbg_bus", "panic");
+			} else
+#endif
+			pr_err("cmd kickoff timed out (%d) ctl=%d\n", rc, ctl->num);
 		} else if (ctx->pp_timeout_report_cnt == MAX_RECOVERY_TRIALS) {
 			MDSS_XLOG(0xbad2);
 			MDSS_XLOG_TOUT_HANDLER("mdp", "dsi0_ctrl", "dsi0_phy",
@@ -2745,6 +2786,15 @@ static int mdss_mdp_cmd_kickoff(struct m
 		mctl = mdss_mdp_get_main_ctl(ctl);
 	mdss_mdp_cmd_dsc_reconfig(mctl);
 
+#if defined(CONFIG_FB_MSM_MDSS_SAMSUNG)
+	/* send recovery pck before sending image date (for ESD recovery) */
+	mdss_mdp_ctl_intf_event(ctl, MDSS_SAMSUNG_EVENT_PANEL_ESD_RECOVERY,
+		NULL, CTL_INTF_EVENT_FLAG_SKIP_BROADCAST);
+	/* MULTI_RESOLUTION	*/
+	mdss_mdp_ctl_intf_event(ctl, MDSS_SAMSUNG_EVENT_MULTI_RESOLUTION,
+		NULL, CTL_INTF_EVENT_FLAG_DEFAULT);
+#endif
+
 	mdss_mdp_cmd_set_partial_roi(ctl);
 
 	/*
@@ -3523,4 +3573,3 @@ int mdss_mdp_cmd_start(struct mdss_mdp_c
 
 	return 0;
 }
-
