--- original/drivers/usb/phy/phy-msm-usb.c	2020-05-07 08:31:25.985785449 +0200
+++ changed/drivers/usb/phy/phy-msm-usb.c	2019-06-03 13:39:52.000000000 +0200
@@ -124,7 +124,9 @@ static int dcp_max_current = IDEV_CHG_MA
 module_param(dcp_max_current, int, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(dcp_max_current, "max current drawn for DCP charger");
 
+#ifdef OTG_WAIT_PMIC
 static DECLARE_COMPLETION(pmic_vbus_init);
+#endif
 static struct msm_otg *the_msm_otg;
 static bool debug_bus_voting_enabled;
 
@@ -139,12 +141,24 @@ static u32 bus_freqs[USB_NOC_NUM_VOTE][U
 static char bus_clkname[USB_NUM_BUS_CLOCKS][20] = {"bimc_clk", "snoc_clk",
 						"pcnoc_clk"};
 static bool bus_clk_rate_set;
+#ifdef CONFIG_USB_NOTIFY_LAYER
+#include "phy-msm-usb_sec.c"
+#endif
 
 static void dbg_inc(unsigned *idx)
 {
 	*idx = (*idx + 1) & (DEBUG_MAX_MSG-1);
 }
 
+/* Wrapper function for set_vbus_state() */
+static void msm_otg_set_vbus_state(int online);
+void sec_otg_set_vbus_state(int online)
+{
+	pr_err("%s online value is %d \n", __func__, online);
+	msm_otg_set_vbus_state(online);
+}
+EXPORT_SYMBOL(sec_otg_set_vbus_state);
+
 static void
 msm_otg_dbg_log_event(struct usb_phy *phy, char *event, int d1, int d2)
 {
@@ -153,6 +167,8 @@ msm_otg_dbg_log_event(struct usb_phy *ph
 	unsigned long long t;
 	unsigned long nanosec;
 
+	pr_info("%s : %d %d\n", event, d1, d2);
+
 	if (!enable_dbg_log)
 		return;
 
@@ -470,7 +486,7 @@ static void ulpi_init(struct msm_otg *mo
 			pr_debug("ulpi: write 0x%02x to 0x%02x\n",
 					seq[0], seq[1]);
 
-		dev_vdbg(motg->phy.dev, "ulpi: write 0x%02x to 0x%02x\n",
+		dev_info(motg->phy.dev, "ulpi: write 0x%02x to 0x%02x\n",
 				seq[0], seq[1]);
 		msm_otg_dbg_log_event(&motg->phy, "ULPI WRITE", seq[0], seq[1]);
 		ulpi_write(&motg->phy, seq[0], seq[1]);
@@ -1555,6 +1571,7 @@ static int msm_otg_resume(struct msm_otg
 	disable_irq(motg->irq);
 	if (motg->phy_irq)
 		disable_irq(motg->phy_irq);
+
 	wake_lock(&motg->wlock);
 
 	/*
@@ -1684,6 +1701,7 @@ skip_phy_resume:
 	}
 	if (motg->phy_irq)
 		enable_irq(motg->phy_irq);
+
 	enable_irq(motg->irq);
 
 	/* Enable ASYNC_IRQ only during LPM */
@@ -1719,6 +1737,7 @@ static void msm_otg_notify_host_mode(str
 	power_supply_changed(psy);
 }
 
+#ifdef OTG_WAIT_PMIC
 static int msm_otg_notify_chg_type(struct msm_otg *motg)
 {
 	static int charger_type;
@@ -1791,7 +1810,9 @@ psy_error:
 	dev_dbg(motg->phy.dev, "power supply error when setting property\n");
 	return -ENXIO;
 }
+#endif
 
+#ifdef OTG_WAIT_PMIC
 static void msm_otg_set_online_status(struct msm_otg *motg)
 {
 	if (!psy) {
@@ -1803,9 +1824,11 @@ static void msm_otg_set_online_status(st
 	if (power_supply_set_online(psy, false))
 		dev_dbg(motg->phy.dev, "error setting power supply property\n");
 }
+#endif
 
 static void msm_otg_notify_charger(struct msm_otg *motg, unsigned mA)
 {
+#ifdef OTG_WAIT_PMIC
 	struct usb_gadget *g = motg->phy.otg->gadget;
 	struct msm_otg_platform_data *pdata = motg->pdata;
 
@@ -1855,6 +1878,7 @@ static void msm_otg_notify_charger(struc
 	msm_otg_notify_power_supply(motg, mA);
 
 	motg->cur_power = mA;
+#endif
 }
 
 static int msm_otg_set_power(struct usb_phy *phy, unsigned mA)
@@ -1951,6 +1975,9 @@ static void msm_otg_start_host(struct us
 				motg->inputs, otg->phy->state);
 		msm_hsusb_vbus_power(motg, 1);
 		msm_otg_reset(&motg->phy);
+#ifdef CONFIG_USB_HOST_NOTIFY
+		msm_otg_host_notify(motg, on);
+#endif
 
 		if (pdata->otg_control == OTG_PHY_CONTROL)
 			ulpi_write(otg->phy, OTG_COMP_DISABLE,
@@ -2601,7 +2628,9 @@ state_detected:
 				init_completion(&motg->ext_chg_wait);
 				motg->ext_chg_active = DEFAULT;
 		}
+#ifdef OTG_WAIT_PMIC
 		msm_otg_notify_chg_type(motg);
+#endif
 		msm_chg_block_off(motg);
 
 		/* Enable VDP_SRC in case of DCP charger */
@@ -2639,7 +2668,9 @@ static void msm_otg_init_sm(struct msm_o
 {
 	struct msm_otg_platform_data *pdata = motg->pdata;
 	u32 otgsc = readl_relaxed(USB_OTGSC);
+#ifdef OTG_WAIT_PMIC
 	int ret;
+#endif
 
 	switch (pdata->mode) {
 	case USB_OTG:
@@ -2664,10 +2695,14 @@ static void msm_otg_init_sm(struct msm_o
 				clear_bit(B_SESS_VLD, &motg->inputs);
 		} else if (pdata->otg_control == OTG_PMIC_CONTROL) {
 			if (pdata->pmic_id_irq) {
+#ifdef OTG_WAIT_PMIC
 				if (msm_otg_read_pmic_id_state(motg))
 					set_bit(ID, &motg->inputs);
 				else
 					clear_bit(ID, &motg->inputs);
+#else
+				set_bit(ID, &motg->inputs);
+#endif
 			} else if (motg->ext_id_irq) {
 				if (gpio_get_value(pdata->usb_id_gpio))
 					set_bit(ID, &motg->inputs);
@@ -2679,6 +2714,10 @@ static void msm_otg_init_sm(struct msm_o
 				else
 					clear_bit(ID, &motg->inputs);
 			}
+			else {
+				set_bit(ID, &motg->inputs);
+			}
+#ifdef OTG_WAIT_PMIC
 			/*
 			 * VBUS initial state is reported after PMIC
 			 * driver initialization. Wait for it.
@@ -2694,6 +2733,7 @@ static void msm_otg_init_sm(struct msm_o
 				clear_bit(B_SESS_VLD, &motg->inputs);
 				pmic_vbus_init.done = 1;
 			}
+#endif
 		}
 		break;
 	case USB_HOST:
@@ -2707,6 +2747,7 @@ static void msm_otg_init_sm(struct msm_o
 			else
 				clear_bit(B_SESS_VLD, &motg->inputs);
 		} else if (pdata->otg_control == OTG_PMIC_CONTROL) {
+#ifdef OTG_WAIT_PMIC
 			/*
 			 * VBUS initial state is reported after PMIC
 			 * driver initialization. Wait for it.
@@ -2722,6 +2763,7 @@ static void msm_otg_init_sm(struct msm_o
 				clear_bit(B_SESS_VLD, &motg->inputs);
 				pmic_vbus_init.done = 1;
 			}
+#endif
 		} else if (pdata->otg_control == OTG_USER_CONTROL) {
 			set_bit(ID, &motg->inputs);
 			set_bit(B_SESS_VLD, &motg->inputs);
@@ -2814,6 +2856,13 @@ static void msm_otg_sm_work(struct work_
 			dev_dbg(&motg->pdev->dev, "failed to add BAM core\n");
 
 		msm_otg_init_sm(motg);
+
+		if (!psy) {
+			psy = power_supply_get_by_name("msm-usb");
+			if (!psy)
+				pr_err("couldn't get usb power supply\n");
+		}
+
 		otg->phy->state = OTG_STATE_B_IDLE;
 		if (!test_bit(B_SESS_VLD, &motg->inputs) &&
 				test_bit(ID, &motg->inputs)) {
@@ -2935,6 +2984,7 @@ static void msm_otg_sm_work(struct work_
 			msm_otg_start_peripheral(otg, 0);
 			msm_otg_dbg_log_event(&motg->phy, "RT PM: B_PERI A PUT",
 				get_pm_runtime_counter(dev), 0);
+
 			/* Schedule work to finish cable disconnect processing*/
 			otg->phy->state = OTG_STATE_B_IDLE;
 			/* _put for _get done on cable connect in B_IDLE */
@@ -3058,6 +3108,7 @@ static irqreturn_t msm_otg_irq(int irq,
 static void msm_otg_set_vbus_state(int online)
 {
 	struct msm_otg *motg = the_msm_otg;
+#ifdef OTG_WAIT_PMIC
 	static bool init;
 
 	motg->vbus_state = online;
@@ -3079,7 +3130,19 @@ static void msm_otg_set_vbus_state(int o
 		if (!test_and_clear_bit(B_SESS_VLD, &motg->inputs) && init)
 			return;
 	}
+#else
+	if (online) {
+		pr_info("PMIC: BSV set\n");
+		set_bit(B_SESS_VLD, &motg->inputs);
+		motg->chg_state = USB_CHG_STATE_DETECTED;
+		motg->chg_type = USB_SDP_CHARGER;
+	} else {
+		pr_info("PMIC: BSV clear\n");
+		clear_bit(B_SESS_VLD, &motg->inputs);
+	}
+#endif
 
+#ifdef OTG_WAIT_PMIC
 	/* do not queue state m/c work if id is grounded */
 	if (!test_bit(ID, &motg->inputs) &&
 		!motg->pdata->vbus_low_as_hostmode) {
@@ -3126,6 +3189,7 @@ out:
 		}
 		return;
 	}
+#endif
 
 	msm_otg_dbg_log_event(&motg->phy, "CHECK VBUS EVENT DURING SUSPEND",
 			atomic_read(&motg->pm_suspended),
@@ -3189,6 +3253,7 @@ static void msm_id_status_w(struct work_
 	}
 }
 
+#ifdef OTG_WAIT_PMIC
 #define MSM_ID_STATUS_DELAY	5 /* 5msec */
 static irqreturn_t msm_id_irq(int irq, void *data)
 {
@@ -3200,6 +3265,7 @@ static irqreturn_t msm_id_irq(int irq, v
 
 	return IRQ_HANDLED;
 }
+#endif
 
 int msm_otg_pm_notify(struct notifier_block *notify_block,
 					unsigned long mode, void *unused)
@@ -3814,7 +3880,7 @@ set_msm_otg_perf_mode(struct device *dev
 		const char *buf, size_t count)
 {
 	struct msm_otg *motg = the_msm_otg;
-	int ret;
+	int ret = 0;
 	long clk_rate;
 
 	pr_debug("%s: enable:%d\n", __func__, !strnicmp(buf, "enable", 6));
@@ -4273,6 +4339,15 @@ struct msm_otg_platform_data *msm_otg_dt
 				&pdata->default_mode);
 	of_property_read_u32(node, "qcom,hsusb-otg-phy-type",
 				&pdata->phy_type);
+
+	pr_info("%s: init_seq =%x,%x,%x , otg_mode=%d , otg_control=%d\n",
+			__func__,
+			pdata->phy_init_seq[0],
+			pdata->phy_init_seq[2],
+			pdata->phy_init_seq[4],
+			pdata->mode,
+			pdata->otg_control);
+
 	pdata->disable_reset_on_disconnect = of_property_read_bool(node,
 				"qcom,hsusb-otg-disable-reset");
 	pdata->pnoc_errata_fix = of_property_read_bool(node,
@@ -4360,7 +4435,9 @@ static int msm_otg_probe(struct platform
 	struct usb_phy *phy;
 	struct msm_otg_platform_data *pdata;
 	void __iomem *tcsr;
+#ifdef OTG_WAIT_PMIC
 	int id_irq = 0;
+#endif
 
 	dev_info(&pdev->dev, "msm_otg probe\n");
 
@@ -4833,6 +4910,9 @@ static int msm_otg_probe(struct platform
 	phy->set_power = msm_otg_set_power;
 	phy->set_suspend = msm_otg_set_suspend;
 	phy->dbg_event = msm_otg_dbg_log_event;
+#ifdef CONFIG_USB_HOST_NOTIFY
+	phy->set_suspend = NULL;
+#endif
 
 	phy->io_ops = &msm_otg_io_ops;
 
@@ -4851,6 +4931,7 @@ static int msm_otg_probe(struct platform
 		goto free_async_irq;
 	}
 
+#ifdef OTG_WAIT_PMIC
 	if (motg->pdata->mode == USB_OTG &&
 		motg->pdata->otg_control == OTG_PMIC_CONTROL &&
 		!motg->phy_irq) {
@@ -4925,6 +5006,7 @@ static int msm_otg_probe(struct platform
 			dev_dbg(&pdev->dev, "PMIC does ID detection\n");
 		}
 	}
+#endif
 
 	platform_set_drvdata(pdev, motg);
 	device_init_wakeup(&pdev->dev, 1);
@@ -4974,8 +5056,8 @@ static int msm_otg_probe(struct platform
 		pm_runtime_use_autosuspend(&pdev->dev);
 	}
 
-	motg->usb_psy.name = "usb";
-	motg->usb_psy.type = POWER_SUPPLY_TYPE_USB;
+	motg->usb_psy.name = "msm-usb";
+	motg->usb_psy.type = POWER_SUPPLY_TYPE_UNKNOWN;
 	motg->usb_psy.supplied_to = otg_pm_power_supplied_to;
 	motg->usb_psy.num_supplicants = ARRAY_SIZE(otg_pm_power_supplied_to);
 	motg->usb_psy.properties = otg_pm_power_props_usb;
@@ -5047,7 +5129,9 @@ remove_cdev:
 	}
 	if (psy)
 		power_supply_unregister(psy);
+#ifdef OTG_WAIT_PMIC
 remove_phy:
+#endif
 	usb_remove_phy(&motg->phy);
 free_async_irq:
 	free_irq(motg->async_irq, motg);
