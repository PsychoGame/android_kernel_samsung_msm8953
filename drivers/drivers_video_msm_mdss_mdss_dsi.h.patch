--- original/drivers/video/msm/mdss/mdss_dsi.h	2020-05-07 08:31:26.059784783 +0200
+++ changed/drivers/video/msm/mdss/mdss_dsi.h	2019-06-03 13:39:53.000000000 +0200
@@ -99,6 +99,9 @@ enum dsi_panel_bl_ctrl {
 	BL_PWM,
 	BL_WLED,
 	BL_DCS_CMD,
+#if defined(CONFIG_FB_MSM_MDSS_SAMSUNG)
+	BL_SS_PWM,
+#endif
 	UNKNOWN_CTRL,
 };
 
@@ -107,6 +110,9 @@ enum dsi_panel_status_mode {
 	ESD_BTA,
 	ESD_REG,
 	ESD_REG_NT35596,
+#if defined(CONFIG_FB_MSM_MDSS_SAMSUNG)
+	ESD_REG_IRQ,
+#endif
 	ESD_TE,
 	ESD_MAX,
 };
@@ -130,6 +136,10 @@ enum dsi_lane_map_type {
 enum dsi_pm_type {
 	/* PANEL_PM not used as part of power_data in dsi_shared_data */
 	DSI_PANEL_PM,
+#if defined(CONFIG_FB_MSM_MDSS_SAMSUNG)
+	DSI_PANEL_PM_LP11,
+	DSI_PANEL_PM_LP11_OFF,
+#endif
 	DSI_CORE_PM,
 	DSI_CTRL_PM,
 	DSI_PHY_PM,
@@ -331,6 +341,11 @@ struct dsi_panel_cmds {
 	struct dsi_cmd_desc *cmds;
 	int cmd_cnt;
 	int link_state;
+#if defined(CONFIG_FB_MSM_MDSS_SAMSUNG)
+	char *read_size;
+	char *read_startoffset;
+	char *name;
+#endif
 };
 
 struct dsi_panel_timing {
@@ -355,6 +370,13 @@ struct dsi_pinctrl_res {
 	struct pinctrl *pinctrl;
 	struct pinctrl_state *gpio_state_active;
 	struct pinctrl_state *gpio_state_suspend;
+#if defined(CONFIG_FB_MSM_MDSS_SAMSUNG)
+	struct pinctrl_state *samsung_gpio_control0_state_active;
+	struct pinctrl_state *samsung_gpio_control0_state_suspend;
+	struct pinctrl_state *samsung_gpio_control1_state_active;
+	struct pinctrl_state *samsung_gpio_control1_state_suspend;
+#endif
+
 };
 
 struct panel_horizontal_idle {
@@ -405,6 +427,9 @@ struct mdss_dsi_ctrl_pdata {
 	int (*check_read_status) (struct mdss_dsi_ctrl_pdata *pdata);
 	int (*cmdlist_commit)(struct mdss_dsi_ctrl_pdata *ctrl, int from_mdp);
 	void (*switch_mode) (struct mdss_panel_data *pdata, int mode);
+#if defined(CONFIG_FB_MSM_MDSS_SAMSUNG)
+	int (*event_handler)(struct mdss_panel_data *pdata, int event, void *arg);
+#endif
 	struct mdss_panel_data panel_data;
 	unsigned char *ctrl_base;
 	struct dss_io_data ctrl_io;
@@ -460,6 +485,14 @@ struct mdss_dsi_ctrl_pdata {
 	u32 byte_clk_rate_bkp;
 	bool refresh_clk_rate; /* flag to recalculate clk_rate */
 	struct dss_module_power panel_power_data;
+#if defined(CONFIG_FB_MSM_MDSS_SAMSUNG)
+	/* panel_power_data: tx before LP11
+	 * panel_power_data_lp11: tx after LP11
+	 */
+	struct dss_module_power panel_power_data_lp11;
+	struct dss_module_power panel_power_data_lp11_off;
+
+#endif
 	struct dss_module_power power_data[DSI_MAX_PM]; /* for 8x10 */
 	u32 dsi_irq_mask;
 	struct mdss_hw *dsi_hw;
@@ -675,6 +708,9 @@ void mdss_dsi_set_reg(struct mdss_dsi_ct
 	u32 mask, u32 val);
 int mdss_dsi_phy_pll_reset_status(struct mdss_dsi_ctrl_pdata *ctrl);
 int mdss_dsi_panel_power_ctrl(struct mdss_panel_data *pdata, int power_state);
+#if defined(CONFIG_FB_MSM_MDSS_SAMSUNG)
+void mdss_dsi_samsung_poc_perf_mode_ctl(struct mdss_dsi_ctrl_pdata *ctrl, int enable);
+#endif
 
 static inline const char *__mdss_dsi_pm_name(enum dsi_pm_type module)
 {
@@ -695,6 +731,10 @@ static inline const char *__mdss_dsi_pm_
 	case DSI_CTRL_PM:	return "qcom,ctrl-supply-entries";
 	case DSI_PHY_PM:	return "qcom,phy-supply-entries";
 	case DSI_PANEL_PM:	return "qcom,panel-supply-entries";
+#if defined(CONFIG_FB_MSM_MDSS_SAMSUNG)
+	case DSI_PANEL_PM_LP11:	return "qcom,panel-supply-entries-lp11";
+	case DSI_PANEL_PM_LP11_OFF:	return "qcom,panel-supply-entries-lp11-off";
+#endif
 	default:		return "???";
 	}
 }
@@ -896,4 +936,14 @@ static inline bool mdss_dsi_cmp_panel_re
 	return status_buf.data[i] == status_val[i];
 }
 
+#if defined(CONFIG_FB_MSM_MDSS_SAMSUNG)
+int mdss_dsi_on(struct mdss_panel_data *pdata);
+int mdss_samsung_parse_dcs_cmds(struct device_node *np,
+		struct dsi_panel_cmds *pcmds, char *cmd_key, char *link_key);
+u32 mdss_samsung_panel_cmd_read(struct mdss_dsi_ctrl_pdata *ctrl,
+		struct dsi_panel_cmds *pcmds, int read_size);
+struct mdss_dsi_ctrl_pdata *mdss_dsi_get_ctrl(u32 ctrl_id);
+int mdss_samsung_dsi_pinctrl_set_state(
+	struct mdss_dsi_ctrl_pdata *ctrl_pdata, int control_number, bool active);
+#endif
 #endif /* MDSS_DSI_H */
