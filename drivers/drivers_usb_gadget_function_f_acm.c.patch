--- original/drivers/usb/gadget/function/f_acm.c	2020-05-07 08:31:25.874786448 +0200
+++ changed/drivers/usb/gadget/function/f_acm.c	2019-06-03 13:39:52.000000000 +0200
@@ -25,6 +25,9 @@
 #include "u_serial.h"
 #include "gadget_chips.h"
 
+#ifdef CONFIG_USB_DUN_SUPPORT
+#include "serial_acm.c"
+#endif
 
 /*
  * This CDC ACM function support just wraps control functions and
@@ -489,6 +492,9 @@ static int acm_setup(struct usb_function
 		 * host sets the ACM_CTRL_DTR bit; and when it clears
 		 * that bit, we should return to that no-flow state.
 		 */
+#ifdef CONFIG_USB_DUN_SUPPORT
+		notify_control_line_state((unsigned long)w_value);
+#endif
 		acm->port_handshake_bits = w_value;
 		pr_debug("%s: USB_CDC_REQ_SET_CONTROL_LINE_STATE: DTR:%d RST:%d\n",
 				__func__, w_value & ACM_CTRL_DTR ? 1 : 0,
@@ -646,8 +652,9 @@ static int acm_notify_serial_state(struc
 {
 	struct usb_composite_dev *cdev = acm->port.func.config->cdev;
 	int			status;
+	unsigned long	flags;
 
-	spin_lock(&acm->lock);
+	spin_lock_irqsave(&acm->lock, flags);
 	if (acm->notify_req) {
 		dev_dbg(&cdev->gadget->dev, "acm ttyGS%d serial state %04x\n",
 			acm->port_num, acm->serial_state);
@@ -657,7 +664,7 @@ static int acm_notify_serial_state(struc
 		acm->pending = true;
 		status = 0;
 	}
-	spin_unlock(&acm->lock);
+	spin_unlock_irqrestore(&acm->lock, flags);
 	return status;
 }
 
@@ -665,20 +672,33 @@ static void acm_cdc_notify_complete(stru
 {
 	struct f_acm		*acm = req->context;
 	u8			doit = false;
+   	unsigned long	flags;
 
 	/* on this call path we do NOT hold the port spinlock,
 	 * which is why ACM needs its own spinlock
 	 */
-	spin_lock(&acm->lock);
+	spin_lock_irqsave(&acm->lock, flags);
 	if (req->status != -ESHUTDOWN)
 		doit = acm->pending;
 	acm->notify_req = req;
-	spin_unlock(&acm->lock);
+	spin_unlock_irqrestore(&acm->lock, flags);
 
 	if (doit)
 		acm_notify_serial_state(acm);
 }
 
+#ifdef CONFIG_USB_DUN_SUPPORT
+void acm_notify(void *dev, u16 state)
+{
+	struct f_acm    *acm = (struct f_acm *)dev;
+	if (acm) {
+		acm->serial_state = state;
+	acm_notify_serial_state(acm);
+	}
+}
+EXPORT_SYMBOL(acm_notify);
+#endif
+
 /* connect == the TTY link is open */
 
 static void acm_connect(struct gserial *port)
@@ -728,7 +748,9 @@ acm_bind(struct usb_configuration *c, st
 {
 	struct usb_composite_dev *cdev = c->cdev;
 	struct f_acm		*acm = func_to_acm(f);
+#ifndef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
 	struct usb_string	*us;
+#endif
 	int			status;
 	struct usb_ep		*ep;
 
@@ -737,6 +759,18 @@ acm_bind(struct usb_configuration *c, st
 	 */
 
 	/* maybe allocate device-global string IDs, and patch descriptors */
+#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
+	if (acm_string_defs[0].id == 0) {
+		status = usb_string_ids_tab(c->cdev, acm_string_defs);
+		if (status < 0)
+			return status;
+		acm_control_interface_desc.iInterface =
+			acm_string_defs[ACM_CTRL_IDX].id;
+		acm_data_interface_desc.iInterface =
+			acm_string_defs[ACM_DATA_IDX].id;
+		acm_iad_descriptor.iFunction = acm_string_defs[ACM_IAD_IDX].id;
+	}
+#else
 	us = usb_gstrings_attach(cdev, acm_strings,
 			ARRAY_SIZE(acm_string_defs));
 	if (IS_ERR(us))
@@ -744,6 +778,7 @@ acm_bind(struct usb_configuration *c, st
 	acm_control_interface_desc.iInterface = us[ACM_CTRL_IDX].id;
 	acm_data_interface_desc.iInterface = us[ACM_DATA_IDX].id;
 	acm_iad_descriptor.iFunction = us[ACM_IAD_IDX].id;
+#endif
 
 	/* allocate instance-specific interface IDs, and patch descriptors */
 	status = usb_interface_id(c, f);
@@ -819,6 +854,10 @@ acm_bind(struct usb_configuration *c, st
 		gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",
 		acm->port.in->name, acm->port.out->name,
 		acm->notify->name);
+	/* To notify serial state by datarouter*/
+#ifdef CONFIG_USB_DUN_SUPPORT
+	modem_register(acm);
+#endif
 	return 0;
 
 fail:
@@ -842,7 +881,13 @@ static void acm_unbind(struct usb_config
 {
 	struct f_acm		*acm = func_to_acm(f);
 
+	/* To notify serial state by datarouter*/
+#ifdef CONFIG_USB_DUN_SUPPORT
+	modem_unregister();
+#endif
+#ifndef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
 	acm_string_defs[0].id = 0;
+#endif
 	usb_free_all_descriptors(f);
 	if (acm->notify_req)
 		gs_free_req(acm->notify, acm->notify_req);
@@ -878,7 +923,11 @@ static struct usb_function *acm_alloc_fu
 	acm->port.send_break = acm_send_break;
 	acm->port.send_modem_ctrl_bits = acm_send_modem_ctrl_bits;
 
+#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
+	acm->port.func.name = kasprintf(GFP_KERNEL, "acm%u", opts->port_num);
+#else
 	acm->port.func.name = "acm";
+#endif
 	acm->port.func.strings = acm_strings;
 	/* descriptors are per-instance copies */
 	acm->port.func.bind = acm_bind;
