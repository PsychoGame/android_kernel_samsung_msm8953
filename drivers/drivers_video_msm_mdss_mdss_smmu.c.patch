--- original/drivers/video/msm/mdss/mdss_smmu.c	2020-05-07 08:31:26.133784118 +0200
+++ changed/drivers/video/msm/mdss/mdss_smmu.c	2019-06-03 13:39:53.000000000 +0200
@@ -27,6 +27,7 @@
 #include <linux/of_platform.h>
 #include <linux/msm_dma_iommu_mapping.h>
 #include <linux/vmalloc.h>
+#include <linux/delay.h>
 
 #include <linux/qcom_iommu.h>
 #include <asm/dma-iommu.h>
@@ -284,6 +285,10 @@ static int mdss_smmu_map_dma_buf_v2(stru
 {
 	int rc;
 	struct mdss_smmu_client *mdss_smmu = mdss_smmu_get_cb(domain);
+#if defined(CONFIG_FB_MSM_MDSS_SAMSUNG)
+	int retry_cnt;
+#endif
+
 	if (!mdss_smmu) {
 		pr_err("not able to get smmu context\n");
 		return -EINVAL;
@@ -291,8 +296,26 @@ static int mdss_smmu_map_dma_buf_v2(stru
 	ATRACE_BEGIN("map_buffer");
 	rc = msm_dma_map_sg_lazy(mdss_smmu->dev, table->sgl, table->nents, dir,
 		dma_buf);
+#if defined(CONFIG_FB_MSM_MDSS_SAMSUNG)
+	if (!in_interrupt()) {
+		if (rc != table->nents) {
+			for (retry_cnt = 0; retry_cnt < 62 ; retry_cnt++) {
+				/* To wait free page by memory reclaim*/
+				msleep(16);
+
+				pr_err("dma map sg failed : retry (%d)\n", retry_cnt);
+				rc = msm_dma_map_sg_lazy(mdss_smmu->dev, table->sgl, table->nents, dir,
+					dma_buf);
+
+				if (rc == table->nents)
+					break;
+			}
+		}
+	}
+#endif
+
 	if (rc != table->nents) {
-		pr_err("dma map sg failed\n");
+		pr_err("dma map sg failed(%d)\n", rc);
 		return -ENOMEM;
 	}
 	ATRACE_END("map_buffer");
