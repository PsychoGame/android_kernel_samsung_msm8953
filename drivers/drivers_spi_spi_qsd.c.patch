--- original/drivers/spi/spi_qsd.c	2020-05-07 08:31:25.434790406 +0200
+++ changed/drivers/spi/spi_qsd.c	2019-06-03 13:39:52.000000000 +0200
@@ -45,6 +45,10 @@
 #include <linux/msm-bus-board.h>
 #include "spi_qsd.h"
 
+#ifdef CONFIG_SEC_FACTORY
+#undef CONFIG_ESE_SECURE
+#endif
+
 #define SPI_MAX_BYTES_PER_WORD			(4)
 
 static int msm_spi_pm_resume_runtime(struct device *device);
@@ -1760,6 +1764,14 @@ static int msm_spi_setup(struct spi_devi
 	u32              spi_ioc;
 	u32              spi_config;
 	u32              mask;
+#ifdef ENABLE_SENSORS_FPRINT_SECURE
+	if (spi->master->bus_num == CONFIG_SENSORS_FP_SPI_NUMBER)
+		return 0;
+#endif
+#ifdef CONFIG_ESE_SECURE
+	if (spi->master->bus_num == CONFIG_ESE_SECURE_SPI_PORT)
+		return 0;
+#endif
 
 	if (spi->bits_per_word < 4 || spi->bits_per_word > 32) {
 		dev_err(&spi->dev, "%s: invalid bits_per_word %d\n",
@@ -2318,6 +2330,321 @@ static int msm_spi_bam_get_resources(str
 	return 0;
 }
 
+#ifdef ENABLE_SENSORS_FPRINT_SECURE
+int fp_spi_clock_get(struct platform_device *pdev)
+{
+	struct spi_master *master = platform_get_drvdata(pdev);
+	struct msm_spi *dd;
+	int rc = 0;
+
+	dd = spi_master_get_devdata(master);
+
+	dd->clk = clk_get(&pdev->dev, "core_clk");
+	if (IS_ERR(dd->clk)) {
+		rc = PTR_ERR(dd->clk);
+		dev_err(&pdev->dev, "%s: unable to get core_clk, rc = %d\n", __func__, rc);
+		return rc;
+	}
+
+	dd->pclk = clk_get(&pdev->dev, "iface_clk");
+	if (IS_ERR(dd->pclk)) {
+		rc = PTR_ERR(dd->pclk);
+		dev_err(&pdev->dev, "%s: unable to get iface_clk, rc = %d\n", __func__, rc);
+		return rc;
+	}
+
+	pr_info("%s sucess\n", __func__);
+	return 0;
+}
+
+int fp_spi_clock_set_rate(struct spi_device *spidev)
+{
+	struct msm_spi *dd;
+
+	if (!spidev) {
+		pr_err("%s: spidev pointer is NULL\n", __func__);
+		return -EFAULT;
+	}
+
+	dd = spi_master_get_devdata(spidev->master);
+	if (!dd) {
+		pr_err("%s: spi master pointer is NULL\n", __func__);
+		return -EFAULT;
+	}
+
+	msm_spi_clock_set(dd, spidev->max_speed_hz);
+
+	pr_info("%s sucess\n", __func__);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(fp_spi_clock_set_rate);
+
+int fp_spi_clock_enable(struct spi_device *spidev)
+{
+	struct msm_spi *dd;
+	int rc;
+
+	if (!spidev) {
+		pr_err("%s: spidev pointer is NULL\n", __func__);
+		return -EFAULT;
+	}
+
+	dd = spi_master_get_devdata(spidev->master);
+	if (!dd) {
+		pr_err("%s: spi master pointer is NULL\n", __func__);
+		return -EFAULT;
+	}
+
+	rc = clk_prepare_enable(dd->clk);
+	if (rc) {
+		pr_err("%s: unable to enable core_clk\n", __func__);
+		return rc;
+	}
+
+	rc = clk_prepare_enable(dd->pclk);
+	if (rc) {
+		pr_err("%s: unable to enable iface_clk\n", __func__);
+		return rc;
+	}
+	pr_info("%s sucess\n", __func__);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(fp_spi_clock_enable);
+
+int fp_spi_clock_disable(struct spi_device *spidev)
+{
+	struct msm_spi *dd;
+
+	if (!spidev) {
+		pr_err("%s: spidev pointer is NULL\n", __func__);
+		return -EFAULT;
+	}
+
+	dd = spi_master_get_devdata(spidev->master);
+	if (!dd) {
+		pr_err("%s: spi master pointer is NULL\n", __func__);
+		return -EFAULT;
+	}
+
+	clk_disable_unprepare(dd->clk);
+	clk_disable_unprepare(dd->pclk);
+
+	pr_info("%s sucess\n", __func__);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(fp_spi_clock_disable);
+
+int fp_spi_request_gpios(struct spi_device *spidev)
+{
+	int i = 0;
+	int result = 0;
+	struct msm_spi *dd;
+
+	if (!spidev) {
+		pr_err("%s: spidev pointer is NULL\n", __func__);
+		return -EFAULT;
+	}
+
+	dd = spi_master_get_devdata(spidev->master);
+	if (!dd) {
+		pr_err("%s: spi master pointer is NULL\n", __func__);
+		return -EFAULT;
+	}
+
+	if (!dd->pdata->use_pinctrl) {
+		for (i = 0; i < ARRAY_SIZE(spi_rsrcs); ++i) {
+			if (dd->spi_gpios[i] >= 0) {
+				result = gpio_request(dd->spi_gpios[i],
+						spi_rsrcs[i]);
+				if (result) {
+					dev_err(dd->dev,
+					"%s: gpio_request for pin %d "
+					"failed with error %d\n"
+					, __func__, dd->spi_gpios[i], result);
+					goto error;
+				}
+			}
+		}
+	} else {
+		result = pinctrl_select_state(dd->pinctrl, dd->pins_active);
+		if (result) {
+			dev_err(dd->dev, "%s: Can not set %s pins\n",
+			__func__, PINCTRL_STATE_DEFAULT);
+			goto error;
+		}
+	}
+	pr_info("%s sucess\n", __func__);
+	return 0;
+error:
+	pr_err("%s error\n", __func__);
+	if (!dd->pdata->use_pinctrl) {
+		for (; --i >= 0;) {
+			if (dd->spi_gpios[i] >= 0)
+				gpio_free(dd->spi_gpios[i]);
+		}
+	}
+	return result;
+}
+EXPORT_SYMBOL_GPL(fp_spi_request_gpios);
+#endif
+
+#ifdef CONFIG_ESE_SECURE
+int ese_spi_clock_get(struct platform_device *pdev)
+{
+	struct spi_master *master = platform_get_drvdata(pdev);
+	struct msm_spi *dd;
+	int rc = 0;
+
+	dd = spi_master_get_devdata(master);
+
+	dd->clk = clk_get(&pdev->dev, "core_clk");
+	if (IS_ERR(dd->clk)) {
+		rc = PTR_ERR(dd->clk);
+		dev_err(&pdev->dev, "%s: unable to get core_clk, rc = %d\n", __func__, rc);
+		return rc;
+	}
+
+	dd->pclk = clk_get(&pdev->dev, "iface_clk");
+	if (IS_ERR(dd->pclk)) {
+		rc = PTR_ERR(dd->pclk);
+		dev_err(&pdev->dev, "%s: unable to get iface_clk, rc = %d\n", __func__, rc);
+		return rc;
+	}
+
+	pr_info("%s sucess\n", __func__);
+	return 0;
+}
+#endif
+int ese_spi_clock_set_rate(struct spi_device *spidev)
+{
+	struct msm_spi *dd;
+
+	if (!spidev) {
+		pr_err("%s: spidev pointer is NULL\n", __func__);
+		return -EFAULT;
+	}
+
+	dd = spi_master_get_devdata(spidev->master);
+	if (!dd) {
+		pr_err("%s: spi master pointer is NULL\n", __func__);
+		return -EFAULT;
+	}
+
+	msm_spi_clock_set(dd, spidev->max_speed_hz);
+
+	pr_info("%s speed:%d sucess\n", __func__, spidev->max_speed_hz);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ese_spi_clock_set_rate);
+
+int ese_spi_clock_enable(struct spi_device *spidev)
+{
+	struct msm_spi *dd;
+	int rc;
+
+	if (!spidev) {
+		pr_err("%s: spidev pointer is NULL\n", __func__);
+		return -EFAULT;
+	}
+
+	dd = spi_master_get_devdata(spidev->master);
+	if (!dd) {
+		pr_err("%s: spi master pointer is NULL\n", __func__);
+		return -EFAULT;
+	}
+
+	rc = clk_prepare_enable(dd->clk);
+	if (rc) {
+		pr_err("%s: unable to enable core_clk\n", __func__);
+		return rc;
+	}
+
+	rc = clk_prepare_enable(dd->pclk);
+	if (rc) {
+		pr_err("%s: unable to enable iface_clk\n", __func__);
+		return rc;
+	}
+	pr_info("%s sucess\n", __func__);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ese_spi_clock_enable);
+
+int ese_spi_clock_disable(struct spi_device *spidev)
+{
+	struct msm_spi *dd;
+
+	if (!spidev) {
+		pr_err("%s: spidev pointer is NULL\n", __func__);
+		return -EFAULT;
+	}
+
+	dd = spi_master_get_devdata(spidev->master);
+	if (!dd) {
+		pr_err("%s: spi master pointer is NULL\n", __func__);
+		return -EFAULT;
+	}
+
+	clk_disable_unprepare(dd->clk);
+	clk_disable_unprepare(dd->pclk);
+
+	pr_info("%s sucess\n", __func__);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ese_spi_clock_disable);
+
+int ese_spi_request_gpios(struct spi_device *spidev)
+{
+	int i = 0;
+	int result = 0;
+	struct msm_spi *dd;
+
+	if (!spidev) {
+		pr_err("%s: spidev pointer is NULL\n", __func__);
+		return -EFAULT;
+	}
+
+	dd = spi_master_get_devdata(spidev->master);
+	if (!dd) {
+		pr_err("%s: spi master pointer is NULL\n", __func__);
+		return -EFAULT;
+	}
+
+	if (!dd->pdata->use_pinctrl) {
+		for (i = 0; i < ARRAY_SIZE(spi_rsrcs); ++i) {
+			if (dd->spi_gpios[i] >= 0) {
+				result = gpio_request(dd->spi_gpios[i],
+						spi_rsrcs[i]);
+				if (result) {
+					dev_err(dd->dev,
+					"%s: gpio_request for pin %d "
+					"failed with error %d\n"
+					, __func__, dd->spi_gpios[i], result);
+					goto error;
+				}
+			}
+		}
+	} else {
+		result = pinctrl_select_state(dd->pinctrl, dd->pins_active);
+		if (result) {
+			dev_err(dd->dev, "%s: Can not set %s pins\n",
+			__func__, PINCTRL_STATE_DEFAULT);
+			goto error;
+		}
+	}
+	pr_info("%s sucess\n", __func__);
+	return 0;
+error:
+	pr_err("%s error\n", __func__);
+	if (!dd->pdata->use_pinctrl) {
+		for (; --i >= 0;) {
+			if (dd->spi_gpios[i] >= 0)
+				gpio_free(dd->spi_gpios[i]);
+		}
+	}
+	return result;
+}
+EXPORT_SYMBOL_GPL(ese_spi_request_gpios);
+
 static int init_resources(struct platform_device *pdev)
 {
 	struct spi_master *master = platform_get_drvdata(pdev);
@@ -2372,7 +2699,14 @@ static int init_resources(struct platfor
 	}
 
 	pclk_enabled = 1;
-
+	if (1
+#ifdef ENABLE_SENSORS_FPRINT_SECURE
+	&& (pdev->id != CONFIG_SENSORS_FP_SPI_NUMBER) 
+#endif
+#ifdef CONFIG_ESE_SECURE
+	&& (pdev->id != CONFIG_ESE_SECURE_SPI_PORT)
+#endif
+	)
 	if (dd->pdata && dd->pdata->ver_reg_exists) {
 		enum msm_spi_qup_version ver =
 					msm_spi_get_qup_hw_ver(&pdev->dev, dd);
@@ -2409,10 +2743,19 @@ static int init_resources(struct platfor
 	 */
 	msm_spi_enable_error_flags(dd);
 
-	writel_relaxed(SPI_IO_C_NO_TRI_STATE, dd->base + SPI_IO_CONTROL);
-	rc = msm_spi_set_state(dd, SPI_OP_STATE_RESET);
-	if (rc)
-		goto err_spi_state;
+	if (1
+#ifdef ENABLE_SENSORS_FPRINT_SECURE
+	&& (pdev->id != CONFIG_SENSORS_FP_SPI_NUMBER) 
+#endif
+#ifdef CONFIG_ESE_SECURE
+	&& (pdev->id != CONFIG_ESE_SECURE_SPI_PORT)
+#endif
+	) {
+		writel_relaxed(SPI_IO_C_NO_TRI_STATE, dd->base + SPI_IO_CONTROL);
+		rc = msm_spi_set_state(dd, SPI_OP_STATE_RESET);
+		if (rc)
+			goto err_spi_state;
+	}
 
 	clk_disable_unprepare(dd->clk);
 	clk_disable_unprepare(dd->pclk);
@@ -2539,6 +2882,24 @@ static int msm_spi_probe(struct platform
 				goto skip_dma_resources;
 			}
 		}
+#ifdef ENABLE_SENSORS_FPRINT_SECURE
+		if (pdev->id == CONFIG_SENSORS_FP_SPI_NUMBER) {
+			fp_spi_clock_get(pdev);
+			pdata->use_bam = false;
+			pr_info("%s: disable bam for BLSP tzspi, spi num(%d)\n",
+					__func__, pdev->id);
+			goto skip_dma_resources;
+		}
+#endif
+#ifdef CONFIG_ESE_SECURE
+		if (pdev->id == CONFIG_ESE_SECURE_SPI_PORT) {
+			ese_spi_clock_get(pdev);
+			pdata->use_bam = false;
+			pr_info("%s: disable bam for BLSP tzspi, spi num(%d)\n",
+					__func__, pdev->id);
+			goto skip_dma_resources;
+		}
+#endif
 		if (!dd->pdata->use_bam)
 			goto skip_dma_resources;
 
@@ -2584,6 +2945,14 @@ skip_dma_resources:
 		dev_err(&pdev->dev, "failed to create dev. attrs : %d\n", rc);
 		goto err_attrs;
 	}
+#ifdef ENABLE_SENSORS_FPRINT_SECURE
+	if (pdev->id == CONFIG_SENSORS_FP_SPI_NUMBER)
+		return 0;
+#endif
+#ifdef CONFIG_ESE_SECURE
+	if (pdev->id == CONFIG_ESE_SECURE_SPI_PORT)
+		return 0;
+#endif
 	spi_debugfs_init(dd);
 
 	return 0;
@@ -2607,6 +2976,15 @@ static int msm_spi_pm_suspend_runtime(st
 	unsigned long	   flags;
 
 	dev_dbg(device, "pm_runtime: suspending...\n");
+#ifdef ENABLE_SENSORS_FPRINT_SECURE
+	if (pdev->id == CONFIG_SENSORS_FP_SPI_NUMBER)
+		return 0;
+#endif
+#ifdef CONFIG_ESE_SECURE
+	if (pdev->id == CONFIG_ESE_SECURE_SPI_PORT)
+		return 0;
+#endif
+
 	if (!master)
 		goto suspend_exit;
 	dd = spi_master_get_devdata(master);
@@ -2652,6 +3030,15 @@ static int msm_spi_pm_resume_runtime(str
 	int               ret = 0;
 
 	dev_dbg(device, "pm_runtime: resuming...\n");
+#ifdef ENABLE_SENSORS_FPRINT_SECURE
+	if (pdev->id == CONFIG_SENSORS_FP_SPI_NUMBER)
+		return 0;
+#endif
+#ifdef CONFIG_ESE_SECURE
+	if (pdev->id == CONFIG_ESE_SECURE_SPI_PORT)
+		return 0;
+#endif
+
 	if (!master)
 		goto resume_exit;
 	dd = spi_master_get_devdata(master);
