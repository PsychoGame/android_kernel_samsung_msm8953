--- original/net/netfilter/nf_conntrack_core.c	2020-05-07 08:31:28.132766134 +0200
+++ changed/net/netfilter/nf_conntrack_core.c	2019-06-03 13:39:54.000000000 +0200
@@ -53,6 +53,10 @@
 #include <net/netfilter/nf_nat_core.h>
 #include <net/netfilter/nf_nat_helper.h>
 
+/* START_OF_KNOX_NPA */
+#include <net/ncm.h>
+/* END_OF_KNOX_NPA */
+
 #define NF_CONNTRACK_VERSION	"0.5.0"
 
 int (*nfnetlink_parse_nat_setup_hook)(struct nf_conn *ct,
@@ -251,6 +255,14 @@ static void nf_ct_add_to_dying_list(stru
 {
 	struct ct_pcpu *pcpu;
 
+	/* START_OF_KNOX_NPA */
+	/* send dying conntrack entry to collect data */
+	del_timer(&ct->npa_timeout);
+	if ( (check_ncm_flag()) && (ct != NULL) && (atomic_read(&ct->startFlow)) ) {
+		knox_collect_conntrack_data(ct, NCM_FLOW_TYPE_CLOSE, 10);
+	}
+	/* END_OF_KNOX_NPA */
+
 	/* add this conntrack to the (per cpu) dying list */
 	ct->cpu = smp_processor_id();
 	pcpu = per_cpu_ptr(nf_ct_net(ct)->ct.pcpu_lists, ct->cpu);
@@ -410,8 +422,34 @@ bool nf_ct_delete(struct nf_conn *ct, u3
 }
 EXPORT_SYMBOL_GPL(nf_ct_delete);
 
+/* START_OF_KNOX_NPA */
+/* Use this function only if struct nf_conn->timeout is of type struct timer_list */
+static void death_by_timeout_npa(unsigned long ul_conntrack)
+{
+	struct nf_conn *tmp = (struct nf_conn *)ul_conntrack;
+	if ( (tmp != NULL) && (check_ncm_flag()) && (check_intermediate_flag()) && (atomic_read(&tmp->startFlow)) && (atomic_read(&tmp->intermediateFlow)) ) {
+		unsigned long timeout = tmp->timeout.expires - jiffies;
+		if ( (timeout > 0) && ((timeout/HZ) > 5) ) {
+			tmp->npa_timeout.expires = (jiffies) + (get_intermediate_timeout() * HZ);
+			add_timer(&tmp->npa_timeout);
+		} else {
+			del_timer(&tmp->npa_timeout);
+		}
+		knox_collect_conntrack_data(tmp, NCM_FLOW_TYPE_INTERMEDIATE, 20);
+		return;
+	}
+	del_timer(&tmp->npa_timeout);
+	return;
+}
+/* END_OF_KNOX_NPA */
+
 static void death_by_timeout(unsigned long ul_conntrack)
 {
+	/* START_OF_KNOX_NPA */
+	struct nf_conn *tmp = (struct nf_conn *)ul_conntrack;
+	atomic_set(&tmp->intermediateFlow, 0);
+	del_timer(&tmp->npa_timeout);
+	/* END_OF_KNOX_NPA */
 	nf_ct_delete((struct nf_conn *)ul_conntrack, 0, 0);
 }
 
@@ -831,6 +869,9 @@ __nf_conntrack_alloc(struct net *net, u1
 		     gfp_t gfp, u32 hash)
 {
 	struct nf_conn *ct;
+	/* START_OF_KNOX_NPA */
+	struct timespec open_timespec;
+	/* END_OF_KNOX_NPA */
 
 	if (unlikely(!nf_conntrack_hash_rnd)) {
 		init_nf_conntrack_hash_rnd();
@@ -867,6 +908,28 @@ __nf_conntrack_alloc(struct net *net, u1
 	       offsetof(struct nf_conn, proto) -
 	       offsetof(struct nf_conn, tuplehash[IP_CT_DIR_MAX]));
 	spin_lock_init(&ct->lock);
+	/* START_OF_KNOX_NPA */
+	/* initialize the conntrack structure members when memory is allocated */
+	if (ct != NULL) {
+		open_timespec = current_kernel_time();
+		ct->open_time = open_timespec.tv_sec;
+		ct->knox_uid = 0;
+		ct->knox_pid = 0;
+		memset(ct->process_name,'\0',sizeof(ct->process_name));
+		memset(ct->domain_name,'\0',sizeof(ct->domain_name));
+		ct->knox_puid = 0;
+		ct->knox_ppid = 0;
+		memset(ct->parent_process_name,'\0',sizeof(ct->parent_process_name));
+		ct->knox_sent = 0;
+		ct->knox_recv = 0;
+		memset(ct->interface_name,'\0',sizeof(ct->interface_name));
+		atomic_set(&ct->startFlow, 0);
+		/* Use 'ct->npa_timeout = 0' if struct nf_conn->timeout is of type u32;
+		   Use 'setup_timer(&ct->npa_timeout, death_by_timeout_npa, (unsigned long)ct)' if struct nf_conn->timeout is of type struct timer_list; */
+		setup_timer(&ct->npa_timeout, death_by_timeout_npa, (unsigned long)ct);
+		atomic_set(&ct->intermediateFlow, 0);
+	}
+	/* END_OF_KNOX_NPA */
 	ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple = *orig;
 	ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode.pprev = NULL;
 	ct->tuplehash[IP_CT_DIR_REPLY].tuple = *repl;
