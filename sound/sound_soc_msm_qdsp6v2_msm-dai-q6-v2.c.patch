--- original/sound/soc/msm/qdsp6v2/msm-dai-q6-v2.c	2020-05-07 08:31:28.722760826 +0200
+++ changed/sound/soc/msm/qdsp6v2/msm-dai-q6-v2.c	2019-06-03 13:39:55.000000000 +0200
@@ -3195,9 +3195,13 @@ static int msm_dai_q6_mi2s_set_fmt(struc
 	dev_get_drvdata(dai->dev);
 
 	if (test_bit(STATUS_PORT_STARTED,
-	    mi2s_dai_data->rx_dai.mi2s_dai_data.status_mask) ||
-	    test_bit(STATUS_PORT_STARTED,
-	    mi2s_dai_data->tx_dai.mi2s_dai_data.status_mask)) {
+#if defined(CONFIG_SND_SOC_MSM8X16_RT5659) || defined(CONFIG_SND_SOC_MSM8X16_RT5665)
+		mi2s_dai_data->rx_dai.mi2s_dai_data.status_mask) &&
+#else /* CONFIG_SND_SOC_MSM8X16_RT5659 */
+		mi2s_dai_data->rx_dai.mi2s_dai_data.status_mask) ||
+#endif /* not CONFIG_SND_SOC_MSM8X16_RT5659 */
+		test_bit(STATUS_PORT_STARTED,
+		mi2s_dai_data->tx_dai.mi2s_dai_data.status_mask)) {
 		dev_err(dai->dev, "%s: err chg i2s mode while dai running",
 			__func__);
 		return -EPERM;
@@ -3413,19 +3417,20 @@ static struct snd_soc_dai_driver msm_dai
 		.playback = {
 			.stream_name = "Quinary MI2S Playback",
 			.aif_name = "QUIN_MI2S_RX",
-			.rates = SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_8000 |
-			SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_96000 |
-			SNDRV_PCM_RATE_192000,
-			.formats = SNDRV_PCM_FMTBIT_S16_LE,
-			.rate_min =     8000,
-			.rate_max =     192000,
+			.rates = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |
+				SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000 |
+				SNDRV_PCM_RATE_192000 | SNDRV_PCM_RATE_44100,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE |
+				SNDRV_PCM_FMTBIT_S24_LE,
+			.rate_min = 8000,
+			.rate_max = 192000,
 		},
 		.capture = {
 			.stream_name = "Quinary MI2S Capture",
 			.aif_name = "QUIN_MI2S_TX",
 			.rates = SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_8000 |
 			SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_96000 |
-			SNDRV_PCM_RATE_192000,
+			SNDRV_PCM_RATE_192000 | SNDRV_PCM_RATE_44100,
 			.formats = (SNDRV_PCM_FMTBIT_S16_LE |
 				    SNDRV_PCM_FMTBIT_S24_LE |
 				    SNDRV_PCM_FMTBIT_S24_3LE |
@@ -5165,16 +5170,18 @@ static int msm_dai_q6_tdm_set_tdm_slot(s
 
 	/* HW only supports 16 and 8 slots configuration */
 	switch (slots) {
+	case 2:
+		cap_mask = 0x3; 
+		break;
+	case 4:
+		cap_mask = 0xF;
+		break;
 	case 8:
 		cap_mask = 0xFF;
 		break;
 	case 16:
 		cap_mask = 0xFFFF;
 		break;
-	case 4:
-		cap_mask = 0xF;
-		break;
-
 	default:
 		dev_err(dai->dev, "%s: invalid slots %d\n",
 			__func__, slots);
@@ -5490,6 +5497,23 @@ static int msm_dai_q6_tdm_hw_params(stru
 	tdm->slot_width = tdm_group->slot_width;
 	tdm->slot_mask = tdm_group->slot_mask;
 
+	/* re-check slot mask */
+	if (tdm->nslots_per_frame != tdm->num_channels)
+	{
+		switch (tdm->num_channels) {
+		case 2:
+			tdm->slot_mask = 0x3;
+			break;
+		case 4:
+			tdm->slot_mask = 0xF;
+			break;
+		default :
+			dev_err(dai->dev, "%s: invalid param channels %d\n",
+				__func__, tdm->num_channels);
+			return -EINVAL;
+		}
+	}
+
 	pr_debug("%s: TDM:\n"
 		"num_channels=%d sample_rate=%d bit_width=%d\n"
 		"nslots_per_frame=%d slot_width=%d slot_mask=0x%x\n"
@@ -5763,8 +5787,10 @@ static int msm_dai_q6_tdm_prepare(struct
 			atomic_inc(group_ref);
 		}
 
-		dai_data->port_cfg.tdm.num_channels = 1;
-		dai_data->port_cfg.tdm.slot_mask = 1;
+		if (dai_data->sec_port_enable) {
+			dai_data->port_cfg.tdm.num_channels = 1;
+			dai_data->port_cfg.tdm.slot_mask = 1;
+		}
 
 		dev_dbg(dai->dev, "\n%s:open sec port id %d TDM rate: %d\n"
 			"dai_data->port_cfg.tdm.slot_mask %x\n"
