--- original/sound/soc/msm/qdsp6v2/q6voice.c	2020-05-07 11:40:16.743311411 +0200
+++ changed/sound/soc/msm/qdsp6v2/q6voice.c	2019-06-03 13:39:55.000000000 +0200
@@ -28,6 +28,10 @@
 #include "q6voice.h"
 #include <sound/adsp_err.h>
 
+#ifdef CONFIG_SEC_SND_ADAPTATION
+#include <sound/sec_adaptation.h>
+#endif /* CONFIG_SEC_SND_ADAPTATION */
+
 #define TIMEOUT_MS 300
 
 
@@ -48,11 +52,17 @@ struct cvd_version_table cvd_version_tab
 		{CVD_VERSION_0_0, CVD_INT_VERSION_0_0},
 		{CVD_VERSION_2_1, CVD_INT_VERSION_2_1},
 		{CVD_VERSION_2_2, CVD_INT_VERSION_2_2},
+		{CVD_VERSION_2_3, CVD_INT_VERSION_2_3},
 };
 
 static struct common_data common;
 static bool module_initialized;
 
+#ifdef CONFIG_SEC_VOC_SOLUTION
+static int loopback_mode = 0;
+static int loopback_prev_mode = 0;
+#endif /* CONFIG_SEC_VOC_SOLUTION */
+
 static int voice_send_enable_vocproc_cmd(struct voice_data *v);
 static int voice_send_netid_timing_cmd(struct voice_data *v);
 static int voice_send_attach_vocproc_cmd(struct voice_data *v);
@@ -123,6 +133,42 @@ static int voice_send_get_sound_focus_cm
 static int voice_send_get_source_tracking_cmd(struct voice_data *v,
 			struct source_tracking_param *sourceTrackingData);
 
+#ifdef CONFIG_SEC_VOC_SOLUTION
+static int send_packet_loopback_cmd(struct voice_data *v, int mode);
+
+int voc_get_loopback_enable(void)
+{
+	return loopback_mode;
+}
+
+void voc_set_loopback_enable(int mode)
+{
+	loopback_prev_mode = loopback_mode;
+
+	if (mode >= LOOPBACK_MAX ||
+	    mode < LOOPBACK_DISABLE) {
+		pr_err("%s : out of range, mode = %d\n",
+			__func__, mode);
+		loopback_mode = LOOPBACK_DISABLE;
+	}
+	else {
+		loopback_mode = mode;
+	}
+
+	pr_info("%s : prev_mode = %d, mode = %d\n",
+		__func__,
+		loopback_prev_mode,
+		loopback_mode);
+}
+#endif /* CONFIG_SEC_VOC_SOLUTION */
+
+#ifdef CONFIG_SEC_SND_ADAPTATION
+struct common_data *voice_get_common_data(void)
+{
+	return &common;
+}
+#endif /* CONFIG_SEC_SND_ADAPTATION */
+
 static void voice_itr_init(struct voice_session_itr *itr,
 			   u32 session_id)
 {
@@ -3381,6 +3427,66 @@ static int voice_map_memory_physical_cmd
 fail:
 	return ret;
 }
+#ifdef CONFIG_SEC_VOC_SOLUTION
+static int send_packet_loopback_cmd(struct voice_data *v, int mode)
+{
+	struct cvs_set_loopback_enable_cmd cvs_set_loopback_cmd;
+	int ret = 0;
+	void *apr_cvs;
+	u16 cvs_handle;
+
+	if (v == NULL) {
+		pr_err("%s: v is NULL\n", __func__);
+		return -EINVAL;
+	}
+	apr_cvs = common.apr_q6_cvs;
+
+	if (!apr_cvs) {
+		pr_err("%s: apr_cvs is NULL.\n", __func__);
+		return -EINVAL;
+	}
+	cvs_handle = voice_get_cvs_handle(v);
+
+	/* fill in the header */
+	cvs_set_loopback_cmd.hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,
+				APR_HDR_LEN(APR_HDR_SIZE), APR_PKT_VER);
+	cvs_set_loopback_cmd.hdr.pkt_size = APR_PKT_SIZE(APR_HDR_SIZE,
+				sizeof(cvs_set_loopback_cmd) - APR_HDR_SIZE);
+	cvs_set_loopback_cmd.hdr.src_port =
+				voice_get_idx_for_session(v->session_id);
+	cvs_set_loopback_cmd.hdr.dest_port = cvs_handle;
+	cvs_set_loopback_cmd.hdr.token = 0;
+	cvs_set_loopback_cmd.hdr.opcode = VOICE_CMD_SET_PARAM;
+
+	cvs_set_loopback_cmd.mem_handle = 0;
+	cvs_set_loopback_cmd.mem_address = 0;
+	cvs_set_loopback_cmd.mem_size = 0x10;
+
+	cvs_set_loopback_cmd.vss_set_loopback.module_id = VOICEPROC_MODULE_VENC;
+	cvs_set_loopback_cmd.vss_set_loopback.param_id = VOICE_PARAM_LOOPBACK_ENABLE;
+	cvs_set_loopback_cmd.vss_set_loopback.param_size = MOD_ENABLE_PARAM_LEN;
+	cvs_set_loopback_cmd.vss_set_loopback.reserved = 0;
+	cvs_set_loopback_cmd.vss_set_loopback.loopback_enable = mode;
+	cvs_set_loopback_cmd.vss_set_loopback.reserved_field = 0;
+
+	v->cvs_state = CMD_STATUS_FAIL;
+	ret = apr_send_pkt(apr_cvs, (uint32_t *) &cvs_set_loopback_cmd);
+	if (ret < 0) {
+		pr_err("%s: sending cvs set loopback enable failed\n", __func__);
+		goto fail;
+	}
+	ret = wait_event_timeout(v->cvs_wait,
+		(v->cvs_state == CMD_STATUS_SUCCESS),
+			msecs_to_jiffies(TIMEOUT_MS));
+	if (!ret) {
+		pr_err("%s: wait_event timeout\n", __func__);
+		goto fail;
+	}
+	return 0;
+fail:
+	return -EINVAL;
+}
+#endif /* CONFIG_SEC_VOC_SOLUTION */
 
 static int voice_pause_voice_call(struct voice_data *v)
 {
@@ -5826,7 +5932,23 @@ int voc_end_voice_call(uint32_t session_
 
 	if (v->voc_state == VOC_RUN || v->voc_state == VOC_ERROR ||
 	    v->voc_state == VOC_CHANGE || v->voc_state == VOC_STANDBY) {
-
+#ifdef CONFIG_SEC_VOC_SOLUTION
+		if ((loopback_mode == LOOPBACK_DISABLE) &&
+		    (loopback_prev_mode == LOOPBACK_ENABLE ||
+		     loopback_prev_mode == LOOPBACK_NODELAY)) {
+			ret = send_packet_loopback_cmd(v, loopback_mode);
+			if (ret < 0) {
+				pr_err("%s: packet loopback disable cmd failed(%d)\n",
+					__func__, ret);
+			} else {
+				pr_info("%s: disable packet loopback\n",
+					__func__);
+			}
+			loopback_prev_mode = 0;
+		}
+#elif defined(CONFIG_SEC_SND_ADAPTATION)
+		voice_sec_loopback_end_cmd(session_id);
+#endif /* CONFIG_SEC_VOC_SOLUTION */
 		pr_debug("%s: VOC_STATE: %d\n", __func__, v->voc_state);
 
 		ret = voice_destroy_vocproc(v);
@@ -6160,7 +6282,22 @@ int voc_start_voice_call(uint32_t sessio
 			pr_err("start voice failed\n");
 			goto fail;
 		}
-
+#ifdef CONFIG_SEC_VOC_SOLUTION
+		if (loopback_mode == LOOPBACK_ENABLE ||
+		    loopback_mode == LOOPBACK_NODELAY) {
+			ret = send_packet_loopback_cmd(v, loopback_mode);
+			if (ret < 0) {
+				pr_err("%s: send packet loopback cmd failed(%d)\n",
+					__func__, ret);
+				goto fail;
+			} else {
+				pr_info("%s: enable packet loopback\n",
+					__func__);
+			}
+		}
+#elif defined(CONFIG_SEC_SND_ADAPTATION)
+		voice_sec_loopback_start_cmd(session_id);
+#endif /* CONFIG_SEC_VOC_SOLUTION */
 		v->voc_state = VOC_RUN;
 	} else {
 		pr_err("%s: Error: Start voice called in state %d\n",
@@ -6229,6 +6366,234 @@ void voc_config_vocoder(uint32_t media_t
 	common.mvs_info.evrc_max_rate = evrc_max_rate;
 }
 
+#ifdef CONFIG_SEC_VOC_SOLUTION
+static int voice_send_nbmode_cmd(struct voice_data *v, int enable)
+{
+	struct cvp_set_nbmode_enable_cmd cvp_nbmode_cmd;
+	int ret = 0;
+	void *apr_cvp;
+	u16 cvp_handle;
+
+	if (v == NULL) {
+		pr_err("%s: v is NULL\n", __func__);
+		return -EINVAL;
+	}
+
+	apr_cvp = common.apr_q6_cvp;
+	if (!apr_cvp) {
+		pr_err("%s: apr_cvp is NULL.\n", __func__);
+		return -EINVAL;
+	}
+
+	cvp_handle = voice_get_cvp_handle(v);
+
+	/* fill in the header */
+	cvp_nbmode_cmd.hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,
+				APR_HDR_LEN(APR_HDR_SIZE),
+				APR_PKT_VER);
+	cvp_nbmode_cmd.hdr.pkt_size = APR_PKT_SIZE(APR_HDR_SIZE,
+		sizeof(cvp_nbmode_cmd) - APR_HDR_SIZE);
+	cvp_nbmode_cmd.hdr.src_port =
+		voice_get_idx_for_session(v->session_id);
+	cvp_nbmode_cmd.hdr.dest_port = cvp_handle;
+	cvp_nbmode_cmd.hdr.token = 0;
+	cvp_nbmode_cmd.hdr.opcode = VSS_ICOMMON_CMD_SET_UI_PROPERTY;
+	cvp_nbmode_cmd.cvp_set_nbmode.module_id = VOICE_VOICEMODE_MODULE;
+	cvp_nbmode_cmd.cvp_set_nbmode.param_id = VOICE_NBMODE_PARAM;
+	cvp_nbmode_cmd.cvp_set_nbmode.param_size = MOD_ENABLE_PARAM_LEN;
+	cvp_nbmode_cmd.cvp_set_nbmode.reserved = 0;
+	cvp_nbmode_cmd.cvp_set_nbmode.enable = enable;
+	cvp_nbmode_cmd.cvp_set_nbmode.reserved_field = 0;
+
+	pr_info("%s(): eanble = %d\n",
+		__func__,
+		cvp_nbmode_cmd.cvp_set_nbmode.enable);
+
+	v->cvp_state = CMD_STATUS_FAIL;
+	v->cvp_nbmode_state = 1;
+	v->async_err = 0;
+	ret = apr_send_pkt(apr_cvp, (uint32_t *) &cvp_nbmode_cmd);
+	if (ret < 0) {
+		pr_err("%s: Failed to send cvp_nbmode_cmd\n",
+			__func__);
+		v->cvp_nbmode_state = 0;
+		return -EINVAL;
+	}
+
+	ret = wait_event_timeout(v->cvp_wait,
+				(v->cvp_state == CMD_STATUS_SUCCESS),
+				msecs_to_jiffies(TIMEOUT_MS));
+
+	v->cvp_nbmode_state = 0;
+	if (!ret) {
+		pr_err("%s: wait_event timeout\n", __func__);
+		return -EINVAL;
+	}
+
+	if (v->async_err > 0) {
+		pr_err("%s: DSP returned error[%s]\n",
+				__func__, adsp_err_get_err_str(
+				v->async_err));
+		ret = adsp_err_get_lnx_err_code(
+				v->async_err);
+		return ret;
+	}
+	return 0;
+}
+
+int voice_sec_set_nbmode(short enable)
+{
+	struct voice_data *v = NULL;
+	int ret = 0;
+	struct voice_session_itr itr;
+
+	pr_debug("%s: Enter\n", __func__);
+
+	mutex_lock(&common.common_lock);
+	voice_itr_init(&itr, ALL_SESSION_VSID);
+	while (voice_itr_get_next_session(&itr, &v)) {
+		if (v != NULL) {
+			mutex_lock(&v->lock);
+			if (is_voc_state_active(v->voc_state) &&
+				(v->lch_mode != VOICE_LCH_START) &&
+				!v->disable_topology)
+				ret = voice_send_nbmode_cmd(v, enable);
+			mutex_unlock(&v->lock);
+		} else {
+			pr_err("%s: invalid session\n", __func__);
+			ret = -EINVAL;
+			break;
+		}
+	}
+	mutex_unlock(&common.common_lock);
+	pr_debug("%s: Exit, ret=%d\n", __func__, ret);
+
+	return ret;
+}
+EXPORT_SYMBOL(voice_sec_set_nbmode);
+
+static int voice_send_dha_data(struct voice_data *v)
+{
+	struct cvp_dha_parm_send_cmd cvp_dha_param_cmd;
+	int ret = 0;
+	void *apr_cvp;
+	u16 cvp_handle;
+
+	if (v == NULL) {
+		pr_err("%s: v is NULL\n", __func__);
+		return -EINVAL;
+	}
+
+	apr_cvp = common.apr_q6_cvp;
+	if (!apr_cvp) {
+		pr_err("%s: apr_cvp is NULL.\n", __func__);
+		return -EINVAL;
+	}
+
+	cvp_handle = voice_get_cvp_handle(v);
+
+	/* fill in the header */
+	cvp_dha_param_cmd.hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,
+				APR_HDR_LEN(APR_HDR_SIZE),
+				APR_PKT_VER);
+	cvp_dha_param_cmd.hdr.pkt_size = APR_PKT_SIZE(APR_HDR_SIZE,
+		sizeof(cvp_dha_param_cmd) - APR_HDR_SIZE);
+	cvp_dha_param_cmd.hdr.src_port =
+		voice_get_idx_for_session(v->session_id);
+	cvp_dha_param_cmd.hdr.dest_port = cvp_handle;
+	cvp_dha_param_cmd.hdr.token = 0;
+	cvp_dha_param_cmd.hdr.opcode = VOICE_CMD_SET_PARAM;
+	cvp_dha_param_cmd.mem_handle = 0;
+	cvp_dha_param_cmd.mem_address = 0;
+	cvp_dha_param_cmd.mem_size = 40;
+	cvp_dha_param_cmd.dha_send.module_id = VOICE_MODULE_DHA;
+	cvp_dha_param_cmd.dha_send.param_id = VOICE_PARAM_DHA_DYNAMIC;
+	cvp_dha_param_cmd.dha_send.param_size = 28;
+	cvp_dha_param_cmd.dha_send.reserved = 0;
+	cvp_dha_param_cmd.dha_send.eq_mode =
+		v->sec_dha_data.dha_mode;
+
+	cvp_dha_param_cmd.dha_send.select =
+				(uint16_t)v->sec_dha_data.dha_select;
+
+	memcpy(cvp_dha_param_cmd.dha_send.param,
+			v->sec_dha_data.dha_params, 24);
+
+	pr_info("%s: send dha param, mode = %d, select=%d\n",
+		__func__,
+		cvp_dha_param_cmd.dha_send.eq_mode,
+		cvp_dha_param_cmd.dha_send.select);
+
+	v->cvp_state = CMD_STATUS_FAIL;
+	v->cvp_dha_state = 1;
+	v->async_err = 0;
+	ret = apr_send_pkt(apr_cvp, (uint32_t *) &cvp_dha_param_cmd);
+	if (ret < 0) {
+		pr_err("%s: Failed to send vpcm_dha_param_send_cmd\n",
+			__func__);
+		v->cvp_dha_state = 0;
+		return -EINVAL;
+	}
+
+	ret = wait_event_timeout(v->cvp_wait,
+				(v->cvp_state == CMD_STATUS_SUCCESS),
+				msecs_to_jiffies(TIMEOUT_MS));
+
+	v->cvp_dha_state = 0;
+	if (!ret) {
+		pr_err("%s: wait_event timeout\n", __func__);
+		return -EINVAL;
+	}
+
+	if (v->async_err > 0) {
+		pr_err("%s: DSP returned error[%s]\n",
+				__func__, adsp_err_get_err_str(
+				v->async_err));
+		ret = adsp_err_get_lnx_err_code(
+				v->async_err);
+		return ret;
+	}
+	return 0;
+}
+
+int voice_sec_set_dha_data(short mode, short select, short *parameters)
+{
+	struct voice_data *v = NULL;
+	int ret = 0;
+	int i = 0;
+	struct voice_session_itr itr;
+
+	pr_debug("%s: Enter\n", __func__);
+
+	mutex_lock(&common.common_lock);
+	voice_itr_init(&itr, ALL_SESSION_VSID);
+	while (voice_itr_get_next_session(&itr, &v)) {
+		if (v != NULL) {
+			mutex_lock(&v->lock);
+			v->sec_dha_data.dha_mode = mode;
+			v->sec_dha_data.dha_select = select;
+			for (i = 0; i < 12; i++)
+				v->sec_dha_data.dha_params[i] = (short)parameters[i];
+			if (is_voc_state_active(v->voc_state) &&
+				(v->lch_mode != VOICE_LCH_START) &&
+				!v->disable_topology)
+				ret = voice_send_dha_data(v);
+			mutex_unlock(&v->lock);
+		} else {
+			pr_err("%s: invalid session\n", __func__);
+			ret = -EINVAL;
+			break;
+		}
+	}
+	mutex_unlock(&common.common_lock);
+	pr_debug("%s: Exit, ret=%d\n", __func__, ret);
+
+	return ret;
+}
+
+EXPORT_SYMBOL(voice_sec_set_dha_data);
+#endif
+
 static int32_t qdsp_mvm_callback(struct apr_client_data *data, void *priv)
 {
 	uint32_t *ptr = NULL;
@@ -6556,6 +6921,22 @@ static int32_t qdsp_cvs_callback(struct
 				pr_debug("%s: VOICE_CMD_SET_PARAM\n", __func__);
 				rtac_make_voice_callback(RTAC_CVS, ptr,
 							data->payload_size);
+#ifdef CONFIG_SEC_VOC_SOLUTION
+				if ((loopback_mode == LOOPBACK_DISABLE) &&
+				    (loopback_prev_mode == LOOPBACK_ENABLE ||
+				     loopback_prev_mode == LOOPBACK_NODELAY)) {
+					pr_info("%s: loopback disable\n", __func__);
+					v->cvs_state = CMD_STATUS_SUCCESS;
+					wake_up(&v->cvs_wait);
+				}
+
+				if (loopback_mode == LOOPBACK_ENABLE ||
+				    loopback_mode == LOOPBACK_NODELAY) {
+					pr_info("%s: loopback enable\n", __func__);
+					v->cvs_state = CMD_STATUS_SUCCESS;
+					wake_up(&v->cvs_wait);
+				}
+#endif /* CONFIG_SEC_VOC_SOLUTION */
 				break;
 			case VOICE_CMD_GET_PARAM:
 				pr_debug("%s: VOICE_CMD_GET_PARAM\n",
@@ -6611,6 +6992,11 @@ static int32_t qdsp_cvs_callback(struct
 
 		cvs_voc_pkt = v->shmem_info.sh_buf.buf[1].data;
 		if (cvs_voc_pkt != NULL &&  common.mvs_info.ul_cb != NULL) {
+			if (v->shmem_info.sh_buf.buf[1].size <
+				((3 * sizeof(uint32_t)) + cvs_voc_pkt[2])) {
+				pr_err("%s: invalid voc pkt size\n", __func__);
+				return -EINVAL;
+			}			
 			/* cvs_voc_pkt[0] contains tx timestamp */
 			common.mvs_info.ul_cb((uint8_t *)&cvs_voc_pkt[3],
 					      cvs_voc_pkt[2],
@@ -6836,6 +7222,12 @@ static int32_t qdsp_cvp_callback(struct
 				pr_debug("%s: VOICE_CMD_SET_PARAM\n", __func__);
 				rtac_make_voice_callback(RTAC_CVP, ptr,
 							data->payload_size);
+#ifdef CONFIG_SEC_VOC_SOLUTION
+				if (v->cvp_dha_state) {
+					v->cvp_state = CMD_STATUS_SUCCESS;
+					wake_up(&v->cvp_wait);
+				}
+#endif /* CONFIG_SEC_VOC_SOLUTION*/
 				break;
 			case VOICE_CMD_GET_PARAM:
 				pr_debug("%s: VOICE_CMD_GET_PARAM\n",
@@ -6898,6 +7290,19 @@ static int32_t qdsp_cvp_callback(struct
 				v->async_err = ptr[1];
 				wake_up(&v->cvp_wait);
 				break;
+#ifdef CONFIG_SEC_VOC_SOLUTION
+			case VSS_ICOMMON_CMD_DHA_SET:
+				pr_info("%s: got ack from cvp for dha set\n", __func__);
+				v->cvp_state = CMD_STATUS_SUCCESS;
+				wake_up(&v->cvp_wait);
+				break;
+			case VSS_ICOMMON_CMD_SET_UI_PROPERTY:
+				if (v->cvp_nbmode_state) {
+					v->cvp_state = CMD_STATUS_SUCCESS;
+					wake_up(&v->cvp_wait);
+				}
+				break;
+#endif /* CONFIG_SEC_VOC_SOLUTION */
 			default:
 				pr_debug("%s: not match cmd = 0x%x\n",
 					  __func__, ptr[0]);
