--- original/sound/soc/msm/msm8952.c	2020-05-07 08:31:28.707760961 +0200
+++ changed/sound/soc/msm/msm8952.c	2019-06-03 13:39:55.000000000 +0200
@@ -32,6 +32,15 @@
 #include "../codecs/msm8x16-wcd.h"
 #include "../codecs/wsa881x-analog.h"
 #include <linux/regulator/consumer.h>
+
+#ifdef CONFIG_SEC_MPP_SHARE
+#include <linux/sec_mux_sel.h>
+#endif /* CONFIG_SEC_MPP_SHARE */
+#ifdef CONFIG_SAMSUNG_JACK
+#include <linux/sec_jack.h>
+#include <linux/qpnp/qpnp-adc.h>
+#include <linux/qpnp/pin.h>
+#endif /* CONFIG_SAMSUNG_JACK */
 #define DRV_NAME "msm8952-asoc-wcd"
 
 #define BTSCO_RATE_8KHZ 8000
@@ -78,12 +87,15 @@ static atomic_t auxpcm_mi2s_clk_ref;
 
 static int msm8952_enable_dig_cdc_clk(struct snd_soc_codec *codec, int enable,
 					bool dapm);
+#ifdef CONFIG_SND_SOC_WCD_MBHC
 static bool msm8952_swap_gnd_mic(struct snd_soc_codec *codec);
+#endif /* #ifdef CONFIG_SND_SOC_WCD_MBHC */
 static int msm8952_mclk_event(struct snd_soc_dapm_widget *w,
 			      struct snd_kcontrol *kcontrol, int event);
 static int msm8952_wsa_switch_event(struct snd_soc_dapm_widget *w,
 			      struct snd_kcontrol *kcontrol, int event);
 
+#ifdef CONFIG_SND_SOC_WCD_MBHC
 /*
  * Android L spec
  * Need to report LINEIN
@@ -106,6 +118,28 @@ static struct wcd_mbhc_config mbhc_cfg =
 	.key_code[7] = 0,
 	.linein_th = 5000,
 };
+#endif /* CONFIG_SND_SOC_WCD_MBHC */
+
+#if defined(CONFIG_SEC_SND_TFA98XX)
+struct tfa98xx_conf {
+	int amp_rx_port_id;
+	int sample_rate;
+	int bit_format;
+	int channel;
+};
+
+static struct tfa98xx_conf nxp_amp_cfg = {
+	.amp_rx_port_id = 0,
+	.sample_rate = 48000,
+	.bit_format = 16,
+	.channel = 2,
+};
+#endif
+
+#ifdef CONFIG_SAMSUNG_JACK
+static struct snd_soc_jack hs_jack;
+static struct mutex jack_mutex;
+#endif /* CONFIG_SAMSUNG_JACK */
 
 static struct afe_clk_cfg mi2s_rx_clk_v1 = {
 	AFE_API_VERSION_I2S_CONFIG,
@@ -200,13 +234,52 @@ static void param_set_mask(struct snd_pc
 	}
 }
 
+#ifdef CONFIG_SND_EXT_MIC_BIAS
+static int enable_external_mic_bias(struct snd_soc_dapm_widget *w,
+			     struct snd_kcontrol *k, int event)
+{
+	char *handset_mic_text = "Handset Mic";
+	char *secondary_mic_text = "Secondary Mic";
+	struct msm8916_asoc_mach_data *pdata =
+		snd_soc_card_get_drvdata(w->codec->component.card);
+
+	pr_info("%s: %s event=%d\n", __func__, w->name, event);
+
+	if (strnstr(w->name, handset_mic_text, strlen(w->name)))	{
+		if (SND_SOC_DAPM_EVENT_ON(event))
+			gpio_direction_output(pdata->mainmic_bias_gpio, 1);
+		else
+			gpio_direction_output(pdata->mainmic_bias_gpio, 0);
+	}
+	else if (strnstr(w->name, secondary_mic_text, strlen(w->name)))	{
+		if (SND_SOC_DAPM_EVENT_ON(event))
+			gpio_direction_output(pdata->submic_bias_gpio, 1);
+		else
+			gpio_direction_output(pdata->submic_bias_gpio, 0);
+	}
+	else	{
+		pr_err("%s: %s do not support external mic bias\n", __func__, w->name);
+	}
+		
+	return 0;
+}
+#endif /* CONFIG_SND_EXT_MIC_BIAS */
+
 static const struct snd_soc_dapm_widget msm8952_dapm_widgets[] = {
 
 	SND_SOC_DAPM_SUPPLY_S("MCLK", -1, SND_SOC_NOPM, 0, 0,
 	msm8952_mclk_event, SND_SOC_DAPM_POST_PMD),
+#ifdef CONFIG_SND_EXT_MIC_BIAS
+	SND_SOC_DAPM_MIC("Handset Mic", enable_external_mic_bias),
+#else
 	SND_SOC_DAPM_MIC("Handset Mic", NULL),
+#endif /* CONFIG_SND_EXT_MIC_BIAS */
 	SND_SOC_DAPM_MIC("Headset Mic", NULL),
+#ifdef CONFIG_SND_EXT_MIC_BIAS
+	SND_SOC_DAPM_MIC("Secondary Mic", enable_external_mic_bias),
+#else
 	SND_SOC_DAPM_MIC("Secondary Mic", NULL),
+#endif /* CONFIG_SND_EXT_MIC_BIAS */
 	SND_SOC_DAPM_MIC("Digital Mic1", NULL),
 	SND_SOC_DAPM_MIC("Digital Mic2", NULL),
 	SND_SOC_DAPM_SUPPLY("VDD_WSA_SWITCH", SND_SOC_NOPM, 0, 0,
@@ -299,6 +372,7 @@ static int enable_spk_ext_pa(struct snd_
 	return 0;
 }
 
+#ifdef CONFIG_SND_SOC_WCD_MBHC
 /* Validate whether US EU switch is present or not */
 int is_us_eu_switch_gpio_support(struct platform_device *pdev,
 		struct msm8916_asoc_mach_data *pdata)
@@ -332,6 +406,7 @@ int is_us_eu_switch_gpio_support(struct
 	}
 	return 0;
 }
+#endif /* CONFIG_SND_SOC_WCD_MBHC */
 
 static int msm_proxy_rx_ch_get(struct snd_kcontrol *kcontrol,
 				struct snd_ctl_elem_value *ucontrol)
@@ -377,6 +452,8 @@ static int msm_mi2s_rx_be_hw_params_fixu
 
 	pr_debug("%s: Num of channels = %d Sample rate = %d\n", __func__,
 			msm_pri_mi2s_rx_ch, mi2s_rx_sample_rate);
+	param_set_mask(params, SNDRV_PCM_HW_PARAM_FORMAT,
+			mi2s_rx_bit_format);
 	rate->min = rate->max = mi2s_rx_sample_rate;
 	channels->min = channels->max = msm_pri_mi2s_rx_ch;
 
@@ -553,7 +630,41 @@ static bool is_mi2s_rx_port(int port_id)
 	return ret;
 }
 
-static uint32_t get_mi2s_clk_val(int port_id)
+#if defined(CONFIG_SEC_SND_TFA98XX)
+static int msm_amp_mi2s_rx_be_hw_params_fixup(struct snd_soc_pcm_runtime *rtd,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_interval *rate = hw_param_interval(params,
+					SNDRV_PCM_HW_PARAM_RATE);
+
+	struct snd_interval *channels = hw_param_interval(params,
+					SNDRV_PCM_HW_PARAM_CHANNELS);
+
+	param_set_mask(params, SNDRV_PCM_HW_PARAM_FORMAT,
+			SNDRV_PCM_FORMAT_S16_LE);
+	rate->min = rate->max = nxp_amp_cfg.sample_rate;
+	channels->min = channels->max = nxp_amp_cfg.channel;
+
+	return 0;
+}
+
+static int msm_amp_mi2s_snd_hw_params(struct snd_pcm_substream *substream,
+			     struct snd_pcm_hw_params *params)
+{
+	pr_debug("%s(): substream = %s  stream = %d\n", __func__,
+		 substream->name, substream->stream);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		param_set_mask(params, SNDRV_PCM_HW_PARAM_FORMAT,
+			       SNDRV_PCM_FORMAT_S16_LE);
+	else
+		param_set_mask(params, SNDRV_PCM_HW_PARAM_FORMAT,
+			       SNDRV_PCM_FORMAT_S16_LE);
+	return 0;
+}
+
+#endif
+
+static uint32_t  get_mi2s_clk_val(int port_id)
 {
 	uint32_t clk_val = 0;
 
@@ -565,6 +676,12 @@ static uint32_t get_mi2s_clk_val(int por
 		clk_val = (mi2s_rx_sample_rate * mi2s_rx_bits_per_sample * 2);
 	else
 		clk_val = (mi2s_tx_sample_rate * mi2s_tx_bits_per_sample * 2);
+#if defined(CONFIG_SEC_SND_TFA98XX)
+	if (nxp_amp_cfg.amp_rx_port_id) {
+		if(port_id == nxp_amp_cfg.amp_rx_port_id)
+			clk_val = ((nxp_amp_cfg.sample_rate) * (nxp_amp_cfg.bit_format) * 2);
+	}
+#endif
 
 	pr_debug("%s: MI2S bit clock value: 0x%0x\n", __func__, clk_val);
 	return clk_val;
@@ -1596,6 +1713,7 @@ static void msm_quin_mi2s_snd_shutdown(s
 	}
 }
 
+#ifdef CONFIG_SND_SOC_WCD_MBHC
 static void *def_msm8952_wcd_mbhc_cal(void)
 {
 	void *msm8952_wcd_cal;
@@ -1644,13 +1762,16 @@ static void *def_msm8952_wcd_mbhc_cal(vo
 
 	return msm8952_wcd_cal;
 }
+#endif /* CONFIG_SND_SOC_WCD_MBHC */
 
 static int msm_audrx_init(struct snd_soc_pcm_runtime *rtd)
 {
 	struct snd_soc_codec *codec = rtd->codec;
 	struct snd_soc_dapm_context *dapm = &codec->dapm;
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+#ifdef CONFIG_SND_SOC_WCD_MBHC
 	int ret = -ENOMEM;
+#endif /* CONFIG_SND_SOC_WCD_MBHC */
 
 	pr_debug("%s(),dev_name%s\n", __func__, dev_name(cpu_dai->dev));
 
@@ -1682,6 +1803,11 @@ static int msm_audrx_init(struct snd_soc
 	msm8x16_wcd_spk_ext_pa_cb(enable_spk_ext_pa, codec);
 	msm8x16_wcd_hph_comp_cb(config_hph_compander_gpio, codec);
 
+#ifdef CONFIG_SAMSUNG_JACK
+	hs_jack.codec = codec;
+#endif /* CONFIG_SAMSUNG_JACK */
+
+#ifdef CONFIG_SND_SOC_WCD_MBHC
 	mbhc_cfg.calibration = def_msm8952_wcd_mbhc_cal();
 	if (mbhc_cfg.calibration) {
 		ret = msm8x16_wcd_hs_detect(codec, &mbhc_cfg);
@@ -1692,11 +1818,18 @@ static int msm_audrx_init(struct snd_soc
 		}
 	}
 	return 0;
-}
+#else
+	return 0;
+#endif /* CONFIG_SND_SOC_WCD_MBHC */
+	}
 
 static struct snd_soc_ops msm8952_quat_mi2s_be_ops = {
 	.startup = msm_quat_mi2s_snd_startup,
+#if defined(CONFIG_SEC_SND_TFA98XX)
+	.hw_params = msm_amp_mi2s_snd_hw_params,
+#else
 	.hw_params = msm_mi2s_snd_hw_params,
+#endif
 	.shutdown = msm_quat_mi2s_snd_shutdown,
 };
 
@@ -2351,11 +2484,32 @@ static struct snd_soc_dai_link msm8952_d
 		.ignore_pmdown_time = 1,
 		.be_id = MSM_FRONTEND_DAI_QCHAT,
 	},
+#if defined(CONFIG_SND_SOC_JACK_AUDIO)
+	{/* hw:x,38 */
+		.name = "MSM8952 JACK LowLatency",
+		.stream_name = "MultiMedia17",
+		.cpu_dai_name	= "MultiMedia17",
+		.platform_name	= "msm-pcm-dsp.1",
+		.dynamic = 1,
+		.dpcm_playback = 1,
+		.dpcm_capture = 1,
+		.async_ops = ASYNC_DPCM_SND_SOC_PREPARE |
+			ASYNC_DPCM_SND_SOC_HW_PARAMS,
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.trigger = {SND_SOC_DPCM_TRIGGER_POST,
+			SND_SOC_DPCM_TRIGGER_POST},
+		.ignore_suspend = 1,
+		/* this dainlink has playback support */
+		.ignore_pmdown_time = 1,
+		.be_id = MSM_FRONTEND_DAI_MULTIMEDIA17,
+	},
+#else
 	{/* hw:x,38 */
 		.name = "MSM8X16 Compress10",
 		.stream_name = "Compress10",
 		.cpu_dai_name	= "MultiMedia17",
-		.platform_name  = "msm-compress-dsp",
+		.platform_name	= "msm-compress-dsp",
 		.dynamic = 1,
 		.dpcm_capture = 1,
 		.trigger = {SND_SOC_DPCM_TRIGGER_POST,
@@ -2366,6 +2520,7 @@ static struct snd_soc_dai_link msm8952_d
 		.ignore_pmdown_time = 1,
 		.be_id = MSM_FRONTEND_DAI_MULTIMEDIA17,
 	},
+#endif
 	{/* hw:x,39 */
 		.name = "MSM8X16 Compress11",
 		.stream_name = "Compress11",
@@ -2479,12 +2634,21 @@ static struct snd_soc_dai_link msm8952_d
 		.stream_name = "Quaternary MI2S Playback",
 		.cpu_dai_name = "msm-dai-q6-mi2s.3",
 		.platform_name = "msm-pcm-routing",
+#if defined(CONFIG_SEC_SND_TFA98XX)
+		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS,
+#else
 		.codec_dai_name = "snd-soc-dummy-dai",
 		.codec_name = "snd-soc-dummy",
+#endif
 		.no_pcm = 1,
 		.dpcm_playback = 1,
 		.be_id = MSM_BACKEND_DAI_QUATERNARY_MI2S_RX,
+#if defined(CONFIG_SEC_SND_TFA98XX)
+		.be_hw_params_fixup = msm_amp_mi2s_rx_be_hw_params_fixup,
+#else
 		.be_hw_params_fixup = msm_mi2s_rx_be_hw_params_fixup,
+#endif
 		.ops = &msm8952_quat_mi2s_be_ops,
 		.ignore_pmdown_time = 1, /* dai link has playback support */
 		.ignore_suspend = 1,
@@ -2494,8 +2658,13 @@ static struct snd_soc_dai_link msm8952_d
 		.stream_name = "Quaternary MI2S Capture",
 		.cpu_dai_name = "msm-dai-q6-mi2s.3",
 		.platform_name = "msm-pcm-routing",
+#if defined(CONFIG_SEC_SND_TFA98XX)
+		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS,
+#else
 		.codec_dai_name = "snd-soc-dummy-dai",
 		.codec_name = "snd-soc-dummy",
+#endif
 		.no_pcm = 1,
 		.dpcm_capture = 1,
 		.be_id = MSM_BACKEND_DAI_QUATERNARY_MI2S_TX,
@@ -2688,6 +2857,19 @@ static struct snd_soc_dai_link msm8952_d
 		.ops = &msm8952_quin_mi2s_be_ops,
 		.ignore_suspend = 1,
 	},
+#ifdef CONFIG_SEC_SND_ADAPTATION
+	{
+		.name = "ADAPTATION Hostless",
+		.stream_name = "ADAPTATION Hostless",
+		.cpu_dai_name = "snd-soc-dummy-dai",
+		.platform_name = "q6audio-adaptation",
+		.no_pcm = 1,
+		.ignore_suspend = 1,
+		.ignore_pmdown_time = 1,
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+	},
+#endif /* CONFIG_SEC_SND_ADAPTATION */
 };
 static struct snd_soc_dai_link msm8952_hdmi_dba_dai_link[] = {
 	{
@@ -2819,6 +3001,7 @@ void msm8952_disable_mclk(struct work_st
 	mutex_unlock(&pdata->cdc_mclk_mutex);
 }
 
+#ifdef CONFIG_SND_SOC_WCD_MBHC
 static bool msm8952_swap_gnd_mic(struct snd_soc_codec *codec)
 {
 	struct snd_soc_card *card = codec->component.card;
@@ -2850,6 +3033,7 @@ static bool msm8952_swap_gnd_mic(struct
 
 	return true;
 }
+#endif /* CONFIG_SND_SOC_WCD_MBHC */
 
 static void msm8952_dt_parse_cap_info(struct platform_device *pdev,
 		struct msm8916_asoc_mach_data *pdata)
@@ -2952,6 +3136,116 @@ err:
 	return ret;
 }
 
+#ifdef CONFIG_SAMSUNG_JACK
+void msm8952_set_micbias(bool state)
+{
+	struct snd_soc_jack *jack = &hs_jack;
+	struct snd_soc_codec *codec;
+	struct snd_soc_dapm_context *dapm;
+	char *str = "MIC BIAS Power External2";
+	int ret = 0;
+
+	if (jack->codec == NULL) {
+		pr_err("%s codec is NULL\n", __func__);
+		return;
+	}
+	pr_info("%s : %s, state=%d\n", __func__, str, state);
+
+	mutex_lock(&jack_mutex);
+	codec = jack->codec;
+	dapm = &codec->dapm;
+
+	if (state == true)
+		ret = snd_soc_dapm_force_enable_pin(dapm, str);
+	else
+		ret = snd_soc_dapm_disable_pin(dapm, str);
+
+	if(ret < 0) {
+		pr_err("%s is failed(%d)\n",
+			__func__, ret);
+	}
+
+	snd_soc_dapm_sync(dapm);
+	mutex_unlock(&jack_mutex);
+}
+
+void msm8952_mpp_enable(int earjack_adc, int enable)
+{
+	int rc = 0;
+	struct qpnp_pin_cfg mpp_param = { 
+		.mode = 4,
+		.invert = 0,
+		.output_type = 0,
+		.ain_route = 1,
+		.src_sel = 0,
+		.vin_sel = 3,
+		.master_en = 0,
+	};
+
+	if (earjack_adc > 0) {
+		mpp_param.master_en = enable;
+		rc = qpnp_pin_config(earjack_adc, &mpp_param);
+
+		if (rc < 0)
+			pr_err("%s: failed to config mpp port(%d)\n",
+				__func__, rc);
+	}
+}
+
+static int msm8952_get_adc(void)
+{
+	struct snd_soc_jack *jack = &hs_jack;
+	struct snd_soc_codec *codec;
+	struct msm8916_asoc_mach_data *pdata;
+	struct qpnp_vadc_result result;
+	struct qpnp_vadc_chip *earjack_vadc;
+	uint32_t mpp_ch;
+	int adc;
+
+	if (jack->codec == NULL) {
+		pr_err("%s codec==NULL\n", __func__);
+		return -1;
+	}
+	codec = jack->codec;
+	pdata = snd_soc_card_get_drvdata(codec->component.card);
+
+	mpp_ch = pdata->mpp_ch_scale[0] + P_MUX1_1_3 - 1;
+
+	if (pdata->mpp_ch_scale[2] == 1)
+		mpp_ch = pdata->mpp_ch_scale[0] + P_MUX1_1_1 - 1;
+	else if (pdata->mpp_ch_scale[2] == 3)
+		mpp_ch = pdata->mpp_ch_scale[0] + P_MUX1_1_3 - 1;
+	else
+		pr_err("%s - invalid channel scale=%d\n",
+			__func__, pdata->mpp_ch_scale[2]);
+
+#ifdef CONFIG_SEC_MPP_SHARE
+	if (!pdata->mpp_standalone_mode)
+		sec_mpp_mux_control(EAR_ADC_MUX_SEL_NUM,
+			SEC_MUX_SEL_EAR_ADC, 1);
+#endif /* CONFIG_SEC_MPP_SHARE */
+
+	msm8952_mpp_enable(pdata->earjack_adc, 1);
+
+	earjack_vadc = qpnp_get_vadc(codec->component.card->dev,
+		"earjack-read");
+	qpnp_vadc_read(earjack_vadc,  mpp_ch, &result);
+
+	msm8952_mpp_enable(pdata->earjack_adc, 0);
+
+#ifdef CONFIG_SEC_MPP_SHARE
+	if (!pdata->mpp_standalone_mode)
+		sec_mpp_mux_control(EAR_ADC_MUX_SEL_NUM,
+			SEC_MUX_SEL_EAR_ADC, 0);
+#endif /* CONFIG_SEC_MPP_SHARE */
+
+	/* Get voltage in microvolts */
+	adc = ((int)result.physical)/1000;
+
+	return adc;
+}
+#endif /* CONFIG_SAMSUNG_JACK */
+
 int msm8952_init_wsa_switch_supply(struct platform_device *pdev,
 		struct msm8916_asoc_mach_data *pdata)
 {
@@ -3020,6 +3314,35 @@ int msm8952_init_wsa_switch_supply(struc
 	return ret;
 }
 
+#if defined (CONFIG_SEC_SND_TFA98XX)
+static void tfa98xx_get_codec_name(struct device *dev)
+{
+	struct device_node *np;
+	int ret;
+	int i;
+
+	np = of_get_child_by_name(dev->of_node, "speaker-dai");
+	if (!np) {
+		dev_info(dev, "does not find speaker-dai\n");
+		return;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(msm8952_dai); i++) {
+		if (msm8952_dai[i].codec_name) {
+			continue;
+		}
+		msm8952_dai[i].codec_of_node =
+			of_parse_phandle(np, "sound-dai", 0);
+		ret = snd_soc_of_get_dai_name(np,
+			&msm8952_dai[i].codec_dai_name);
+		if (ret)
+			dev_info(dev, "failed to get speaker_dai\n");
+	}
+
+	return;
+}
+#endif /* CONFIG_SEC_SND_TFA98XX */
+
 static struct snd_soc_card *msm8952_populate_sndcard_dailinks(
 						struct device *dev)
 {
@@ -3029,6 +3352,9 @@ static struct snd_soc_card *msm8952_popu
 
 	card->name = dev_name(dev);
 	len1 = ARRAY_SIZE(msm8952_dai);
+#if defined (CONFIG_SEC_SND_TFA98XX)
+	tfa98xx_get_codec_name(dev);
+#endif /* CONFIG_SEC_SND_TFA98XX */
 	memcpy(msm8952_dai_links, msm8952_dai, sizeof(msm8952_dai));
 	dailink = msm8952_dai_links;
 	if (of_property_read_bool(dev->of_node,
@@ -3058,6 +3384,14 @@ static struct snd_soc_card *msm8952_popu
 	return card;
 }
 
+#if defined(CONFIG_SEC_SND_TFA98XX)
+static struct snd_soc_codec_conf amp_conf[] = {
+	{
+		.name_prefix = "NXP",
+	},
+};
+#endif
+
 static int msm8952_asoc_machine_probe(struct platform_device *pdev)
 {
 	struct snd_soc_card *card;
@@ -3065,16 +3399,18 @@ static int msm8952_asoc_machine_probe(st
 	const char *hs_micbias_type = "qcom,msm-hs-micbias-type";
 	const char *ext_pa = "qcom,msm-ext-pa";
 	const char *mclk = "qcom,msm-mclk-freq";
+#ifdef CONFIG_SND_SOC_WSA881X_ANALOG
 	const char *wsa = "asoc-wsa-codec-names";
 	const char *wsa_prefix = "asoc-wsa-codec-prefixes";
-	const char *type = NULL;
-	const char *ext_pa_str = NULL;
 	const char *wsa_str = NULL;
 	const char *wsa_prefix_str = NULL;
+	char *temp_str = NULL;
+#endif /* CONFIG_SND_SOC_WSA881X_ANALOG */
+	const char *type = NULL;
+	const char *ext_pa_str = NULL;
 	int num_strings;
 	int ret, id, i, val;
 	struct resource	*muxsel;
-	char *temp_str = NULL;
 
 	pdata = devm_kzalloc(&pdev->dev,
 			sizeof(struct msm8916_asoc_mach_data), GFP_KERNEL);
@@ -3159,7 +3495,7 @@ parse_mclk_freq:
 			"%s: error reading dtsi files%d\n", __func__, ret);
 		goto err;
 	}
-
+#ifdef CONFIG_SND_SOC_WSA881X_ANALOG
 	num_strings = of_property_count_strings(pdev->dev.of_node,
 			wsa);
 	if (num_strings > 0) {
@@ -3227,7 +3563,7 @@ parse_mclk_freq:
 			msm8x16_update_int_spk_boost(false);
 		}
 	}
-
+#endif /* CONFIG_SND_SOC_WSA881X_ANALOG */
 	card = msm8952_populate_sndcard_dailinks(&pdev->dev);
 	dev_info(&pdev->dev, "default codec configured\n");
 	num_strings = of_property_count_strings(pdev->dev.of_node,
@@ -3258,14 +3594,14 @@ parse_mclk_freq:
 			pdata->ext_pa = (pdata->ext_pa | QUIN_MI2S_ID);
 	}
 	pr_debug("%s: ext_pa = %d\n", __func__, pdata->ext_pa);
-
+#ifdef CONFIG_SND_SOC_WCD_MBHC
 	ret = is_us_eu_switch_gpio_support(pdev, pdata);
 	if (ret < 0) {
 		pr_err("%s: failed to is_us_eu_switch_gpio_support %d\n",
 				__func__, ret);
 		goto err;
 	}
-
+#endif /* CONFIG_SND_SOC_WCD_MBHC */
 	ret = is_ext_spk_gpio_support(pdev, pdata);
 	if (ret < 0)
 		pr_err("%s:  doesn't support external speaker pa\n",
@@ -3278,6 +3614,7 @@ parse_mclk_freq:
 			__func__, hs_micbias_type);
 		goto err;
 	}
+#ifdef CONFIG_SND_SOC_WCD_MBHC
 	if (!strcmp(type, "external")) {
 		dev_dbg(&pdev->dev, "Headset is using external micbias\n");
 		mbhc_cfg.hs_ext_micbias = true;
@@ -3285,6 +3622,7 @@ parse_mclk_freq:
 		dev_dbg(&pdev->dev, "Headset is using internal micbias\n");
 		mbhc_cfg.hs_ext_micbias = false;
 	}
+#endif  /* CONFIG_SND_SOC_WCD_MBHC */
 
 	ret = of_property_read_u32(pdev->dev.of_node,
 				  "qcom,msm-afe-clk-ver", &val);
@@ -3317,6 +3655,11 @@ parse_mclk_freq:
 	msm8952_dt_parse_cap_info(pdev, pdata);
 
 	card->dev = &pdev->dev;
+#if defined(CONFIG_SEC_SND_TFA98XX)
+	amp_conf[0].of_node = of_parse_phandle(pdev->dev.of_node, "speaker-amps", 0);
+	card->codec_conf = amp_conf;
+	card->num_configs = 1;
+#endif
 	platform_set_drvdata(pdev, card);
 	snd_soc_card_set_drvdata(card, pdata);
 	ret = snd_soc_of_parse_card_name(card, "qcom,model");
@@ -3352,6 +3695,82 @@ parse_mclk_freq:
 			ret);
 		goto err;
 	}
+	dev_info(&pdev->dev, "Sound card %s registered\n", card->name);
+
+#ifdef CONFIG_SAMSUNG_JACK
+#ifdef CONFIG_SEC_MPP_SHARE
+	pdata->mpp_standalone_mode = of_property_read_bool(pdev->dev.of_node,
+		"qcom,mpp-standalone-mode");
+#endif /* CONFIG_SEC_MPP_SHARE */
+	pdata->earjack_adc = of_get_named_gpio(pdev->dev.of_node,
+		"qcom,earjack-adc", 0);
+
+	ret = of_property_read_u32_array(pdev->dev.of_node,
+		"qcom,mpp-channel-scaling", pdata->mpp_ch_scale, 3);
+	if (ret < 0) {
+		dev_info(&pdev->dev, "can`t find mpp-ch from the dt\n");
+		pdata->mpp_ch_scale[0] = 2;
+		pdata->mpp_ch_scale[1] = 1;
+		pdata->mpp_ch_scale[2] = 1;
+	}
+	dev_dbg(&pdev->dev, "mpp-channel-scaling - %d %d %d\n",
+		pdata->mpp_ch_scale[0],
+		pdata->mpp_ch_scale[1],
+		pdata->mpp_ch_scale[2]);
+
+	jack_controls.set_micbias = msm8952_set_micbias;
+	jack_controls.get_adc = msm8952_get_adc;
+	jack_controls.snd_card_registered = 1;
+
+	mutex_init(&jack_mutex);
+#endif /* CONFIG_SAMSUNG_JACK */
+#if defined(CONFIG_SEC_SND_TFA98XX)
+	ret = of_property_read_u32(pdev->dev.of_node,
+		"qcom,nxp-amp-conf", &nxp_amp_cfg.amp_rx_port_id);
+#endif
+#ifdef CONFIG_SND_EXT_MIC_BIAS
+	pdata->mainmic_bias_gpio = of_get_named_gpio(pdev->dev.of_node,
+		"qcom,mainmic-bias-gpio", 0);
+
+	if (pdata->mainmic_bias_gpio < 0) {
+		dev_err(&pdev->dev, "Looking up %s property in node %s failed",
+			"qcom,mainmic-bias-gpio",
+			pdev->dev.of_node->full_name);
+	} else {
+		dev_info(&pdev->dev, "mainmic-bias-gpio = %d\n",
+			pdata->mainmic_bias_gpio);
+
+		ret = gpio_request(pdata->mainmic_bias_gpio, "main_mic_bias");
+		if (ret) {
+			dev_err(&pdev->dev,
+				"mainmic_bias_gpio request failed (%d)\n", ret);
+			gpio_free(pdata->mainmic_bias_gpio);
+			pdata->mainmic_bias_gpio = 0;
+		}
+		gpio_direction_output(pdata->mainmic_bias_gpio, 0);
+	}
+
+	pdata->submic_bias_gpio = of_get_named_gpio(pdev->dev.of_node,
+		"qcom,submic-bias-gpio", 0);
+
+	if (pdata->submic_bias_gpio < 0) {
+		dev_err(&pdev->dev, "Looking up %s property in node %s failed",
+			"qcom,submic-bias-gpio",
+			pdev->dev.of_node->full_name);
+	} else {
+		dev_info(&pdev->dev, "submic-bias-gpio = %d\n",
+			pdata->submic_bias_gpio);
+
+		ret = gpio_request(pdata->submic_bias_gpio, "sub_mic_bias");
+		if (ret) {
+			dev_err(&pdev->dev,
+				"submic_bias_gpio request failed (%d)\n", ret);
+			gpio_free(pdata->submic_bias_gpio);
+			pdata->submic_bias_gpio = 0;
+		}
+		gpio_direction_output(pdata->submic_bias_gpio, 0);
+	}
+#endif /* CONFIG_SND_EXT_MIC_BIAS */
 	return 0;
 err:
 	if (pdata->vaddr_gpio_mux_spkr_ctl)
